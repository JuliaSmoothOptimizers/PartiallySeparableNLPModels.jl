<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PartiallySeparableNLPModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartiallySeparableNLPModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartiallySeparableNLPModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>​</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><p>​</p><ul><li><a href="#Reference">Reference</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></ul><p>​</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>​</p><ul><li><a href="#PartiallySeparableNLPModels.Hv-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.Hv</code></a></li><li><a href="#PartiallySeparableNLPModels.Hv2-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.Hv2</code></a></li><li><a href="#PartiallySeparableNLPModels.Hv_only_product-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.Hv_only_product</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PBFGS.build_PartitionedData_TR_PBFGS-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PBFGS.build_PartitionedData_TR_PBFGS</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PBFGS{G, T}, Vector{T}, Vector{T}}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS!-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PBFGS{G, T}, Vector{T}}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PLBFGS.build_PartitionedData_TR_PLBFGS-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PLBFGS.build_PartitionedData_TR_PLBFGS</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PLBFGS{G, T}, Vector{T}, Vector{T}}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS!-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PLBFGS{G, T}, Vector{T}}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_common.compiled_grad_elmt_fun-Tuple{T} where T"><code>PartiallySeparableNLPModels.Mod_common.compiled_grad_elmt_fun</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree</code></a></li><li><a href="#PartiallySeparableNLPModels.build_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, grad_vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.build_gradient</code></a></li><li><a href="#PartiallySeparableNLPModels.check_Inf_Nan-Union{Tuple{Matrix{Y}}, Tuple{Y}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.check_Inf_Nan</code></a></li><li><a href="#PartiallySeparableNLPModels.check_Inf_Nan-Union{Tuple{Hess_matrix{Y}}, Tuple{Y}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.check_Inf_Nan</code></a></li><li><a href="#PartiallySeparableNLPModels.compiled_grad_of_elmt_fun-Tuple{T} where T"><code>PartiallySeparableNLPModels.compiled_grad_of_elmt_fun</code></a></li><li><a href="#PartiallySeparableNLPModels.construct_Sparse_Hessian-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, Hess_matrix{Y}}} where {T, Y&lt;:Number}"><code>PartiallySeparableNLPModels.construct_Sparse_Hessian</code></a></li><li><a href="#PartiallySeparableNLPModels.construct_set_index_element_view!-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T"><code>PartiallySeparableNLPModels.construct_set_index_element_view!</code></a></li><li><a href="#PartiallySeparableNLPModels.construct_views-Union{Tuple{N}, Tuple{Vector{N}, Vector{Vector{Vector{Int64}}}}} where N&lt;:Number"><code>PartiallySeparableNLPModels.construct_views</code></a></li><li><a href="#PartiallySeparableNLPModels.create_pre_compiled_tree-Union{Tuple{N}, Tuple{Vector{CalculusTreeTools.implementation_tree.type_node{CalculusTreeTools.abstract_expr_node.ab_ex_nd}}, Array{Array{SubArray{N, 1, Vector{N}, Tuple{Vector{Int64}}, false}, 1}, 1}}} where N&lt;:Number"><code>PartiallySeparableNLPModels.create_pre_compiled_tree</code></a></li><li><a href="#PartiallySeparableNLPModels.deduct_partially_separable_structure"><code>PartiallySeparableNLPModels.deduct_partially_separable_structure</code></a></li><li><a href="#PartiallySeparableNLPModels.element_gradient!-Union{Tuple{T}, Tuple{ReverseDiff.CompiledTape, AbstractVector{T}, element_gradient{T}}} where T&lt;:Number"><code>PartiallySeparableNLPModels.element_gradient!</code></a></li><li><a href="#PartiallySeparableNLPModels.element_gradient2!-Union{Tuple{T}, Tuple{Y}, Tuple{Y, AbstractVector{T}, element_gradient{T}}} where {Y, T&lt;:Number}"><code>PartiallySeparableNLPModels.element_gradient2!</code></a></li><li><a href="#PartiallySeparableNLPModels.eval_ni_ones-Union{Tuple{T}, Tuple{T, Int64}} where T"><code>PartiallySeparableNLPModels.eval_ni_ones</code></a></li><li><a href="#PartiallySeparableNLPModels.evaluate_SPS-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_SPS</code></a></li><li><a href="#PartiallySeparableNLPModels.evaluate_SPS_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_SPS_gradient</code></a></li><li><a href="#PartiallySeparableNLPModels.evaluate_SPS_gradient!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}, grad_vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_SPS_gradient!</code></a></li><li><a href="#PartiallySeparableNLPModels.evaluate_SPS_gradient2!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}, grad_vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_SPS_gradient2!</code></a></li><li><a href="#PartiallySeparableNLPModels.evaluate_element_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{element_function, AbstractVector{Y}, SPS{T}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_element_hessian</code></a></li><li><a href="#PartiallySeparableNLPModels.evaluate_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_gradient</code></a></li><li><a href="#PartiallySeparableNLPModels.evaluate_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_hessian</code></a></li><li><a href="#PartiallySeparableNLPModels.evaluate_obj_pre_compiled-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_obj_pre_compiled</code></a></li><li><a href="#PartiallySeparableNLPModels.get_elmnt_fun_index_view-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T"><code>PartiallySeparableNLPModels.get_elmnt_fun_index_view</code></a></li><li><a href="#PartiallySeparableNLPModels.get_index_deleted-Union{Tuple{T}, Tuple{Vector{T}, T, Int64, Float64, Vector{Int64}, Vector{Float64}}} where T"><code>PartiallySeparableNLPModels.get_index_deleted</code></a></li><li><a href="#PartiallySeparableNLPModels.get_related_function-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T"><code>PartiallySeparableNLPModels.get_related_function</code></a></li><li><a href="#PartiallySeparableNLPModels.get_related_var-Tuple{Vector{element_function}, Vector{Vector{Int64}}}"><code>PartiallySeparableNLPModels.get_related_var</code></a></li><li><a href="#PartiallySeparableNLPModels.grad_ni_to_n!-Union{Tuple{Y}, Tuple{element_gradient{Y}, Vector{Int64}, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.grad_ni_to_n!</code></a></li><li><a href="#PartiallySeparableNLPModels.id_hessian!-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, Hess_matrix{Y}}} where {T, Y&lt;:Number}"><code>PartiallySeparableNLPModels.id_hessian!</code></a></li><li><a href="#PartiallySeparableNLPModels.minus_grad_vec!-Union{Tuple{T}, Tuple{grad_vector{T}, grad_vector{T}, grad_vector{T}}} where T&lt;:Number"><code>PartiallySeparableNLPModels.minus_grad_vec!</code></a></li><li><a href="#PartiallySeparableNLPModels.product_matrix_sps-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, Vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.product_matrix_sps</code></a></li><li><a href="#PartiallySeparableNLPModels.product_matrix_sps!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, AbstractVector{Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.product_matrix_sps!</code></a></li><li><a href="#PartiallySeparableNLPModels.product_vector_sps-Union{Tuple{T}, Tuple{Y}, Tuple{Z}, Tuple{SPS{T}, grad_vector{Y}, Vector{Z}}} where {Z&lt;:Number, Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.product_vector_sps</code></a></li><li><a href="#PartiallySeparableNLPModels.struct_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.struct_hessian</code></a></li><li><a href="#PartiallySeparableNLPModels.struct_hessian!-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, AbstractVector{Y}, Hess_matrix{Y}}} where {T, Y&lt;:Number}"><code>PartiallySeparableNLPModels.struct_hessian!</code></a></li></ul><p>​</p><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Hv-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.Hv-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.Hv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Hv(sps, x, v)</code></pre><p>Compute the product hessian vector of the hessian at the point x dot the vector v. This version both ReverseDiff and ForwardDiff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L428-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Hv2-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.Hv2-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.Hv2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Hv2(sps, x, v)</code></pre><p>Compute the product hessian vector of the hessian at the point x dot the vector v. This version uses only ReverseDiff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L846-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Hv_only_product-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.Hv_only_product-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.Hv_only_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Hv_only_product(sps, Hess_matrix, x)</code></pre><p>return the product dot(Hess<em>matrix, x), the function fits with the partitionned representation of the matrix Hess</em>matrix. In order to do the right operations in the right order we need the partially separable structure sps. Less efficient than product<em>matrix</em>sps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L633-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.build_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, grad_vector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.build_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, grad_vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.build_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_gradient(sps, g)</code></pre><p>Constructs a vector of size n from the list of element gradient of the sps structure which has numerous element gradient of size nᵢ. The purpose of the function is to gather these element gradient into a real gradient of size n. The function grad<em>ni</em>to_n! will add element gradient of size nᵢ at the right inside the gradient of size n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L465-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.check_Inf_Nan-Union{Tuple{Hess_matrix{Y}}, Tuple{Y}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.check_Inf_Nan-Union{Tuple{Hess_matrix{Y}}, Tuple{Y}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.check_Inf_Nan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_Inf_Nan(B)</code></pre><p>function that check if an Hess_matrix is not full of Nan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L679-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.check_Inf_Nan-Union{Tuple{Matrix{Y}}, Tuple{Y}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.check_Inf_Nan-Union{Tuple{Matrix{Y}}, Tuple{Y}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.check_Inf_Nan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_Inf_Nan(B)</code></pre><p>function that check if an array contains a Nan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L694-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.compiled_grad_of_elmt_fun-Tuple{T} where T" href="#PartiallySeparableNLPModels.compiled_grad_of_elmt_fun-Tuple{T} where T"><code>PartiallySeparableNLPModels.compiled_grad_of_elmt_fun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compiled_grad_of_elmt_fun(elmt_fun)</code></pre><p>Return  the GradientTape compiled to speed up the ReverseDiff computation of the elmt_fun gradient in the future</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L360-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.construct_Sparse_Hessian-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, Hess_matrix{Y}}} where {T, Y&lt;:Number}" href="#PartiallySeparableNLPModels.construct_Sparse_Hessian-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, Hess_matrix{Y}}} where {T, Y&lt;:Number}"><code>PartiallySeparableNLPModels.construct_Sparse_Hessian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_Sparse_Hessian(sps, B)</code></pre><p>Build from the Partially separable Structure sps and the Hessian approximation B a SpaseArray which represent B in other form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L586-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.construct_set_index_element_view!-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T" href="#PartiallySeparableNLPModels.construct_set_index_element_view!-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T"><code>PartiallySeparableNLPModels.construct_set_index_element_view!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_set_index_element_view(elmt_fun_vector, diff_elmt_tree)</code></pre><p>For each elmt<em>fun ∈ elmt</em>fun<em>vector we set the attribute index</em>element<em>tree</em>position. For doing this we use the function get<em>elmnt</em>fun<em>index</em>view(elmt<em>fun</em>vector, diff<em>elmt</em>tree) that builds a vector of size length(elmt<em>fun</em>vector) with the right indexes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.construct_views-Union{Tuple{N}, Tuple{Vector{N}, Vector{Vector{Vector{Int64}}}}} where N&lt;:Number" href="#PartiallySeparableNLPModels.construct_views-Union{Tuple{N}, Tuple{Vector{N}, Vector{Vector{Vector{Int64}}}}} where N&lt;:Number"><code>PartiallySeparableNLPModels.construct_views</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_views(x, related_vars)</code></pre><ul><li>related_vars a vector (from different element tree) of vector (several element function linked with each tree)</li></ul><p>of vector{int} (a set of index, which represent the elemental variable).</p><ul><li>x a point ∈ Rⁿ</li></ul><p>returns a view of x for each set of index representing the elemental variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L262-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.create_pre_compiled_tree-Union{Tuple{N}, Tuple{Vector{CalculusTreeTools.implementation_tree.type_node{CalculusTreeTools.abstract_expr_node.ab_ex_nd}}, Array{Array{SubArray{N, 1, Vector{N}, Tuple{Vector{Int64}}, false}, 1}, 1}}} where N&lt;:Number" href="#PartiallySeparableNLPModels.create_pre_compiled_tree-Union{Tuple{N}, Tuple{Vector{CalculusTreeTools.implementation_tree.type_node{CalculusTreeTools.abstract_expr_node.ab_ex_nd}}, Array{Array{SubArray{N, 1, Vector{N}, Tuple{Vector{Int64}}, false}, 1}, 1}}} where N&lt;:Number"><code>PartiallySeparableNLPModels.create_pre_compiled_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_pre_compiled_tree(vector_calculus_trees, vector_x_views)</code></pre><p>create a precompiled tree for a particuliar number of evaluation. The size of vector<em>calculus</em>trees and vector<em>x</em>views must match. Each calculus<em>tree from vector</em>calculus<em>trees is pre-compiled for nᵢ evaluation, nᵢ the size of the corresponding element of vector</em>x_views</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.deduct_partially_separable_structure" href="#PartiallySeparableNLPModels.deduct_partially_separable_structure"><code>PartiallySeparableNLPModels.deduct_partially_separable_structure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deduct_partially_separable_structure(expr_tree, n)</code></pre><p>Find the partially separable structure of a function f stored as an expression tree expr_tree. To define properly the size of sparse matrix we need the size of the problem : n. At the end, we get the partially separable structure of f, f(x) = ∑fᵢ(xᵢ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.element_gradient!-Union{Tuple{T}, Tuple{ReverseDiff.CompiledTape, AbstractVector{T}, element_gradient{T}}} where T&lt;:Number" href="#PartiallySeparableNLPModels.element_gradient!-Union{Tuple{T}, Tuple{ReverseDiff.CompiledTape, AbstractVector{T}, element_gradient{T}}} where T&lt;:Number"><code>PartiallySeparableNLPModels.element_gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">element_gradient!(compil_tape, x, g)</code></pre><p>Compute the element grandient from the compil_tape compiled before according to the vector x, and store the result in the vector g Use of ReverseDiff</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L419-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.element_gradient2!-Union{Tuple{T}, Tuple{Y}, Tuple{Y, AbstractVector{T}, element_gradient{T}}} where {Y, T&lt;:Number}" href="#PartiallySeparableNLPModels.element_gradient2!-Union{Tuple{T}, Tuple{Y}, Tuple{Y, AbstractVector{T}, element_gradient{T}}} where {Y, T&lt;:Number}"><code>PartiallySeparableNLPModels.element_gradient2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">element_gradient2!(expr_tree, x, g)</code></pre><p>Compute the element grandient of the function represents by expr_tree according to the vector x, and store the result in the vector g. This was the previous version using ForwardDiff. The actual version using ReverseDiff is more efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L781-L785">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.eval_ni_ones-Union{Tuple{T}, Tuple{T, Int64}} where T" href="#PartiallySeparableNLPModels.eval_ni_ones-Union{Tuple{T}, Tuple{T, Int64}} where T"><code>PartiallySeparableNLPModels.eval_ni_ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_different_CalculusTree( all_element_tree, element_vars)</code></pre><p>Selects the distinct tree from the all<em>element</em>tree to create a Vector of distinct element tree: different<em>calculus</em>tree. In addition to that create a Vector of index to linked the tree from all<em>element</em>tree to different<em>calculus</em>tree : different<em>calculus</em>tree<em>index. element</em>vars is used to count the numbers of variables used in a tree, if the number of variables is different we don&#39;t test the tree and avoid to test the equality between trees. length(different<em>calculus</em>tree<em>index) == length(all</em>element<em>tree) == length(element</em>vars) return (different<em>calculus</em>tree, different<em>calculus</em>tree_index)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L297-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.evaluate_SPS-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.evaluate_SPS-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_SPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_SPS(sps,x)</code></pre><p>Evaluate the structure sps on the point x ∈ Rⁿ. Since we work on subarray of x, we allocate x to the structure sps in a first time. Once this step is done we select the calculus tree needed as well as the view of x needed. Then we evaluate the different calculus tree on the needed point (since the same function appear a lot of time). At the end we sum the result</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L372-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.evaluate_SPS_gradient!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}, grad_vector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.evaluate_SPS_gradient!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}, grad_vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_SPS_gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_SPS_gradient!(sps,x,g)</code></pre><p>Compute the gradient of the partially separable structure sps, and store the result in the grad<em>vector structure g. Using ReversDiff package. Not obvious good behaviour with Threads.@threads, sometime yes sometime no. Noted that we use the previously compiled GradientTape in element</em>gradient! that use ReverseDiff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L397-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.evaluate_SPS_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.evaluate_SPS_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_SPS_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_SPS_gradient(sps,x)</code></pre><p>Return the gradient of the partially separable structure sps at the point x. Using ReversDiff package. Not obvious good behaviour with Threads.@threads, sometime yes sometime no. Noted that we use the previously compiled GradientTape in element_gradient! that use ReverseDiff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.evaluate_SPS_gradient2!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}, grad_vector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.evaluate_SPS_gradient2!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}, grad_vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_SPS_gradient2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_SPS_gradient2!(sps,x,g)</code></pre><p>Compute the gradient of the partially separable structure sps, and store the result in the grad_vector structure g. Using ForwardDiff package. Bad behaviour with Threads.@threads. This was the previous version using ForwardDiff. The actual version using ReverseDiff is more efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L766-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.evaluate_element_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{element_function, AbstractVector{Y}, SPS{T}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.evaluate_element_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{element_function, AbstractVector{Y}, SPS{T}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_element_hessian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_element_hessian(fᵢ,xᵢ)</code></pre><p>Compute the Hessian of the elemental function fᵢ : Gᵢ a nᵢ × nᵢ matrix. So xᵢ a vector of size nᵢ. The result of the function is the triplet of the sparse matrix Gᵢ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L527-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.evaluate_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Vector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.evaluate_gradient-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_gradient(sps,x)</code></pre><p>evalutate the gradient of the partially separable function f = ∑ fι, stored in the sps structure at the point x, return a vector of size n (the number of variable) which is the gradient. Première version de la fonction inutile car inefficace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L823-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.evaluate_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.evaluate_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_hessian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_hessian(sps,x)</code></pre><p>evalutate the hessian of the partially separable function f = ∑ fᵢ, stored in the sps structure at the point x. Return the sparse matrix of the hessian of size n × n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L509-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.evaluate_obj_pre_compiled-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.evaluate_obj_pre_compiled-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T, Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.evaluate_obj_pre_compiled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_obj_pre_compiled(sps, point_x)</code></pre><p>Evaluate the structure sps at point<em>x using the precompiled element tree for nᵢ evaluation. This function is the current evaluate</em>SPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.get_elmnt_fun_index_view-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T" href="#PartiallySeparableNLPModels.get_elmnt_fun_index_view-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T"><code>PartiallySeparableNLPModels.get_elmnt_fun_index_view</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_elmnt_fun_index_view(vector_element_fun, different_element_tree)</code></pre><p>For each element<em>fun ∈ vector</em>element<em>fun, returns the position of the linked element tree corresponding in different</em>element_tree. It will be use later for retrieve a view of the variable used by each element function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.get_index_deleted-Union{Tuple{T}, Tuple{Vector{T}, T, Int64, Float64, Vector{Int64}, Vector{Float64}}} where T" href="#PartiallySeparableNLPModels.get_index_deleted-Union{Tuple{T}, Tuple{Vector{T}, T, Int64, Float64, Vector{Int64}, Vector{Float64}}} where T"><code>PartiallySeparableNLPModels.get_index_deleted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_index_deleted(tree_vector, tree, numbervar, vector_numbervar)</code></pre><p>retrieve the indexes of tree<em>vector such that for all i ∈ indexes tree</em>vector[i] == tree. This function used numbervar and vector_numbervar to speed up the comparison by avoiding equality between trees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.get_related_function-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T" href="#PartiallySeparableNLPModels.get_related_function-Union{Tuple{T}, Tuple{Vector{element_function}, Vector{T}}} where T"><code>PartiallySeparableNLPModels.get_related_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_related_function(elmt_functionS, calculusTreeS)</code></pre><p>Cette fonction récupère les indices des fonctions éléments elmt_functionS lié aux quelques arbres de calculs calculusTreeS de la structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L346-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.get_related_var-Tuple{Vector{element_function}, Vector{Vector{Int64}}}" href="#PartiallySeparableNLPModels.get_related_var-Tuple{Vector{element_function}, Vector{Vector{Int64}}}"><code>PartiallySeparableNLPModels.get_related_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_related_var(vec_elmt_fun, index_elmt_tree)</code></pre><p>Renvoie un tableau d&#39;entier de 3 dimensions. La première dimension de taille length(index<em>elmt</em>tree) correspond au nombre de fonctions éléments distinctes (arbre de calcul). Pour chaque fonction éléments distinctes e nous avons un vecteur vₑ :: Vector{Vector{Int}} tel que length(vₑ) == length(index<em>elmt</em>tree[e]) index<em>elmt</em>tree[e] contient les indices des fonctions éléments rattachés à la fonction élément e. Le résultat de la fonction renverra pour chaque indice de fonctions éléments les variables utilisées ( :: Vector{Int}) par celle-ci ce qui nous donne un tableau 3 dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L332-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.grad_ni_to_n!-Union{Tuple{Y}, Tuple{element_gradient{Y}, Vector{Int64}, AbstractVector{Y}}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.grad_ni_to_n!-Union{Tuple{Y}, Tuple{element_gradient{Y}, Vector{Int64}, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.grad_ni_to_n!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad_ni_to_n!(element_gradient, used_var, gradient)</code></pre><p>Add to the gradient the value of element<em>gradient according to the vector of used</em>var given. length(used<em>var) == length(element</em>gradient)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L485-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.id_hessian!-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, Hess_matrix{Y}}} where {T, Y&lt;:Number}" href="#PartiallySeparableNLPModels.id_hessian!-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, Hess_matrix{Y}}} where {T, Y&lt;:Number}"><code>PartiallySeparableNLPModels.id_hessian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">id_hessian!(sps, B)</code></pre><p>Construct a kinf of Id Hessian, it will initialize each element Hessian Bᵢ with an Id matrix, B =  ∑ᵢᵐ Uᵢᵀ Bᵢ Uᵢ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L573-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.minus_grad_vec!-Union{Tuple{T}, Tuple{grad_vector{T}, grad_vector{T}, grad_vector{T}}} where T&lt;:Number" href="#PartiallySeparableNLPModels.minus_grad_vec!-Union{Tuple{T}, Tuple{grad_vector{T}, grad_vector{T}, grad_vector{T}}} where T&lt;:Number"><code>PartiallySeparableNLPModels.minus_grad_vec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minus_grad_vec!(g1,g2,res)</code></pre><p>Store in res: g1 minus g2, but g1 and g2 have a particular structure which is grad_vector{T}. We need this operation to have the difference for each element gradient for TR method. g1 = gₖ and g2 = gₖ₋₁.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L496-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.product_matrix_sps!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, AbstractVector{Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.product_matrix_sps!-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, AbstractVector{Y}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.product_matrix_sps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">product_matrix_sps!(sps,B,x,Bx)</code></pre><p>This function make the product of the structure B which represents a symetric matrix and the vector x, the result is stored in Bx. We need the structure sps for the variable used in each B[i], to replace B[i]*x[i] in the result vector by using f_inter!.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L605-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.product_matrix_sps-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, Vector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.product_matrix_sps-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, Hess_matrix{Y}, Vector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.product_matrix_sps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">product_matrix_sps(sps,B,x)</code></pre><p>This function make the product of the structure B which represents a symetric matrix and the vector x. We need the structure sps for the variable used in each B[i], to replace B[i]*x[i] in the result vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L594-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.product_vector_sps-Union{Tuple{T}, Tuple{Y}, Tuple{Z}, Tuple{SPS{T}, grad_vector{Y}, Vector{Z}}} where {Z&lt;:Number, Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.product_vector_sps-Union{Tuple{T}, Tuple{Y}, Tuple{Z}, Tuple{SPS{T}, grad_vector{Y}, Vector{Z}}} where {Z&lt;:Number, Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.product_vector_sps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">product_vector_sps(sps, g, x)</code></pre><p>compute the product g⊤ x = ∑ Uᵢ⊤ gᵢ⊤ xᵢ. So we need the sps structure to get the Uᵢ. On ne s&#39;en sert pas en pratique mais peut-être pratique pour faire des vérifications</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L664-L668">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.struct_hessian!-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, AbstractVector{Y}, Hess_matrix{Y}}} where {T, Y&lt;:Number}" href="#PartiallySeparableNLPModels.struct_hessian!-Union{Tuple{Y}, Tuple{T}, Tuple{SPS{T}, AbstractVector{Y}, Hess_matrix{Y}}} where {T, Y&lt;:Number}"><code>PartiallySeparableNLPModels.struct_hessian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">struct_hessian!(sps,x,H)</code></pre><p>Evalutate the hessian of the partially separable function, stored in the sps structure at the point x. Store the Hessian in a particular structure H :: Hess_matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L562-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.struct_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}}} where {Y&lt;:Number, T}" href="#PartiallySeparableNLPModels.struct_hessian-Union{Tuple{T}, Tuple{Y}, Tuple{SPS{T}, AbstractVector{Y}}} where {Y&lt;:Number, T}"><code>PartiallySeparableNLPModels.struct_hessian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">struct_hessian(sps,x)</code></pre><p>evalutate the hessian of the partially separable function, stored in the sps structure at the point x. Return the Hessian in a particular structure : Hess_matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/old_version/PartiallySeparableStructure.jl#L544-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	evaluate_grad_part_data(part_data,x)</code></pre><p>Build the gradient vector at the point x from the element gradient computed and stored in part_data.pg .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/M_partitioned_data.jl#L143-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	evaluate_y_part_data!(part_data,x,s)
	evaluate_y_part_data!(part_data,s)</code></pre><p>Compute the element gradients differences such as ∇̂fᵢ(x+s)-∇̂fᵢ(x) for each element functions.  It stores the results in part<em>data.pv. evaluate</em>y<em>part</em>data!(part_data,s) consider that pg is alreagy the gradient of the point x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/M_partitioned_data.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{T}, Tuple{T, Vector{Y}}} where {T&lt;:PartitionedData, Y&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	product_part_data_x!(part_data, x)</code></pre><p>Return the product of the partitioned matrix <code>part_data*x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/M_partitioned_data.jl#L63-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PBFGS.build_PartitionedData_TR_PBFGS-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_PBFGS.build_PartitionedData_TR_PBFGS-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PBFGS.build_PartitionedData_TR_PBFGS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_PartitionedData_TR_PBFGS(expr_tree, n)</code></pre><p>Find the partially separable structure of a function f stored as an expression tree expr_tree. To define properly the size of sparse matrix we need the size of the problem : n. At the end, we get the partially separable structure of f, f(x) = ∑fᵢ(xᵢ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/partitioneddata_pbfgs.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS!-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PBFGS{G, T}, Vector{T}}} where {G, T&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS!-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PBFGS{G, T}, Vector{T}}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	update_PBFGS(pd_pbfgs,s)</code></pre><p>Perform the PBFGS update givent the current iterate x and the next iterate s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/partitioneddata_pbfgs.jl#L52-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PBFGS{G, T}, Vector{T}, Vector{T}}} where {G, T&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PBFGS{G, T}, Vector{T}, Vector{T}}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PBFGS.update_PBFGS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	update_PBFGS(pd_pbfgs,x,s)</code></pre><p>Perform the PBFGS update givent the two iterate x and s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/partitioneddata_pbfgs.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PLBFGS.build_PartitionedData_TR_PLBFGS-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_PLBFGS.build_PartitionedData_TR_PLBFGS-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PLBFGS.build_PartitionedData_TR_PLBFGS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_PartitionedData_TR_PLBFGS(expr_tree, n)</code></pre><p>Find the partially separable structure of a function f stored as an expression tree expr_tree. To define properly the size of sparse matrix we need the size of the problem : n. At the end, we get the partially separable structure of f, f(x) = ∑fᵢ(xᵢ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/partitioneddata_plbfgs.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS!-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PLBFGS{G, T}, Vector{T}}} where {G, T&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS!-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PLBFGS{G, T}, Vector{T}}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	update_PLBFGS(pd_pblfgs,s)</code></pre><p>Perform the PBFGS update givent the current iterate x and the next iterate s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/partitioneddata_plbfgs.jl#L52-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PLBFGS{G, T}, Vector{T}, Vector{T}}} where {G, T&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS-Union{Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PLBFGS{G, T}, Vector{T}, Vector{T}}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PLBFGS.update_PLBFGS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	update_PLBFGS(pd_pblfgs,x,s)</code></pre><p>Perform the PBFGS update givent the two iterate x and s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/partitioneddata_plbfgs.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_common.compiled_grad_elmt_fun-Tuple{T} where T" href="#PartiallySeparableNLPModels.Mod_common.compiled_grad_elmt_fun-Tuple{T} where T"><code>PartiallySeparableNLPModels.Mod_common.compiled_grad_elmt_fun</code></a> — <span class="docstring-category">Method</span></header><section><div><p>compiled<em>grad</em>elmt<em>fun(elmt</em>fun, ni) Return  the GradientTape compiled to speed up the ReverseDiff computation of the elmt_fun gradient in the future</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/common.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T" href="#PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distinct_element_expr_tree(vec_element_expr_tree, vec_element_variables; N)</code></pre><p>Filter the vector vec<em>element</em>expr<em>tree to obtain only the element functions that are distincts as element</em>expr<em>tree. length(element</em>expr<em>tree) == M. In addition it returns index</em>element_tree, who records the index 1 &lt;= i &lt;= M of each element function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/paraynaud/PartiallySeparableNLPModels.jl/blob/f7c7b7db2819af0950e995cf744871d95d466288/src/partitioned_data/common.jl#L16-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 25 February 2022 15:50">Friday 25 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
