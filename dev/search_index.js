var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PartiallySeparableNLPModels, Mod_ab_partitioned_data, Mod_common, Mod_partitionedNLPModel, Mod_PQN]","category":"page"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!-Union{Tuple{Y}, Tuple{Vector{Y}, PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!","text":"evaluate_grad_part_data!(g::Vector{Y}, part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\nevaluate_grad_part_data!(part_data::PartitionedData)\n\nEvaluate in place of g the gradient at the point x after the computation of the element gradients (stored in part_data.pg). When g and x are omitted, it considers that part_data.g and part_data.x are respectively g and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data","text":"gradient = evaluate_grad_part_data(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the gradient vector g at the point x after the computation of the element gradients (stored in part_data.pg).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!-Tuple{PartitionedData}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!","text":"evaluate_obj_part_data!(part_data::PartitionedData)\n\nCompute and store the partially separable objective value stored in part_data, as a sum of element functions, in part_data given part_data.x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data","text":"fx = evaluate_obj_part_data(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the partially separable objective value stored in part_data, computed as a sum of element functions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!","text":"evaluate_y_part_data!(part_data::PartitionedData, x::Vector{Y}, s::Vector{Y}) where {Y <: Number}\nevaluate_y_part_data!(part_data::PartitionedData, s::Vector{Y}) where {Y <: Number}\n\nCompute the element gradients differences such as ∇̂fᵢ(x+s)-∇̂fᵢ(x) for each element functions.  It stores the results in part_data.pv. evaluate_y_part_data!(part_data, s) consider the point part_data.x and the partitioned gradient part_data.pg known.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!-Union{Tuple{Y}, Tuple{Vector{Y}, PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!","text":"product_part_data_x!(res::Vector{Y}, part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\nproduct_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, part_data::PartitionedData, epv::PartitionedStructures.Elemental_pv{Y}) where {Y <: Number}\nproduct_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, pB::T, epv::PartitionedStructures.Elemental_pv{Y}) where {Y <: Number, T <: PartitionedStructures.Part_mat{Y}}\n\nReturn in place of res the product between the partitioned matrix part_data.pB and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x","text":"Bx = product_part_data_x(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the product between the partitioned matrix part_data.pB and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.Element_function","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.Element_function","text":"Element_function\n\nGather the informations indentifying an element function in a PQNNLPModel, and its particular properties. Element_function has fields:\n\ni describing the index of the element function;\nindex_element_tree the index occupied in the element-function vector after the deletion of redundant element functions;\nvariable_indices informing the elemental variable of Element_function\ntype describing Element_function as constant, linear, quadratic, cubic or more non linear;\nconvexity_status describing Element_function as constant, linear, convex, concave or unknown.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function-Tuple{T} where T","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function","text":"element_gradient_tape = compiled_grad_element_function(element_function::T; ni::Int = length(ExpressionTreeForge.get_elemental_variables(element_function)), type = Float64) where {T}\n\nReturn the elment_gradient_tape::GradientTape which speed up the gradient computation of element_function with ReverseDiff.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree","text":"(element_expr_trees, indices_element_tree) = distinct_element_expr_tree(vec_element_expr_tree::Vector{T}, vec_element_variables::Vector{Vector{Int}}; N::Int = length(vec_element_expr_tree)) where {T}\n\nIn practice, there may have several element functions having the same expression tree. distinct_element_expr_tree filters the vector vec_element_expr_tree to return element_expr_trees the distincts element functions. length(element_expr_trees) == M < N == length(vec_element_expr_tree). In addition it returns indices_element_tree, who records the index (1 <= i <= M) related ot the expression tree of each element function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel","text":"Accumulate the supported NLPModels. \n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.PQNNLPModel","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.PQNNLPModel","text":"PQNNLPModel{ T, S, G, M <: AbstractNLPModel{T, S}, Meta <: AbstractNLPModelMeta{T, S}} <: AbstractPQNNLPModel{T, S}\n\nA partitioned quasi-Newton NLPModel. A PQNNLPModel has field:\n\nmeta counting numerous information about the PQNNLPModel;\npart_data allocate the partitioned structures required by a partitioned quasi-Newton trust-region method;\nnlp the original NLPModel.\n\n\n\n\n\n","category":"type"},{"location":"reference/#NLPModels.grad!-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}, AbstractVector{T}}} where {T, S, P<:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPQNNLPModel{T, S}}","page":"Reference","title":"NLPModels.grad!","text":"g = grad!(nlp, x, g)\n\nEvaluate ∇f(x), the gradient of the objective function at x in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NLPModels.obj-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}}} where {T, S, P<:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPQNNLPModel{T, S}}","page":"Reference","title":"NLPModels.obj","text":"f = obj(nlp, x)\n\nEvaluate f(x), the objective function of nlp at x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree-Union{Tuple{NLPModelsJuMP.MathOptNLPModel}, Tuple{T}} where T<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree","text":"expr, n, x0 = get_expr_tree(adnlp::MathOptNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T <: Number}\nexpr, n, x0 = get_expr_tree(adnlp::ADNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T <: Number}\n\nReturn for a MathOptNLPModel or a ADNLPModel: the expression tree of the objective function expr::Expr, the size of the problem n and the initial point x0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.PartitionedData_TR_PQN","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.PartitionedData_TR_PQN","text":"PartitionedData_TR_PQN{G, T <: Number, P <: Part_mat{T}} <: PartitionedData\n\nGather the structures required to run a partitioned quasi-Newton trust-region method. PartitionedData_TR_PQN has fields:\n\nn the size of the problem;\nN the number of element functions;\nvec_elt_fun a Element_function vector, of size N;\nM the number of distinct element-function expression trees;\nvec_elt_complete_expr_tree a Complete_expr_tree vector, of size M;\nelement_expr_tree_table a vector of size M, the i-th element element_expr_tree_table[i]::Vector{Int} informs which element functions have the vec_elt_complete_expr_tree[i] expreesion tree;\nindex_element_tree a vector of size N where each component indicates which Complete_expr_tree from vec_elt_complete_expr_tree use for the corresponding element;\nvec_compiled_element_gradients the vector gathering the compiled tapes for the element gradient evaluations;\nx the current point;\nv a temporary vector;\ns the current step;\npg the partitioned gradient;\npv a temporary partitioned vector;\npy the partitioned gradient difference;\nps the partitioned step;\npB the partitioned matrix (main memory cost);\nfx the current value of the objective function;\nname the name of partitioned quasi-Newton update peformed at each iterate.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.build_PartitionedData_TR_PQN-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T<:Number}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.build_PartitionedData_TR_PQN","text":"partitioneddata_tr_pqn = build_PartitionedData_TR_PQN(expr_tree, n)\n\nReturn the structure required to run a partitioned quasi-Newton trust-region method.  It finds the partially-separable structure of an expression tree expr_tree representing f(x) = ∑fᵢ(xᵢ). Then it allocates the partitioned structures required. Note that to define properly the sparse matrix of the partitioned matrix we need the size of the problem: n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.update_PQN!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.update_PQN!","text":"update_PQN!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, s::Vector{T})\nupdate_PQN!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T})\n\nPerform the partitioned quasi-Newton update given the vectors x and s. When x is omitted, update_PQN! consider that pd_pqn already know the value of x. Moreover, it assumes that the partitioned gradient at x is already computed in pd_pqn.pg.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.update_PQN-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.update_PQN","text":"B = update_PQN(  pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T};\n\nPerform the partitioned quasi-Newton update given the vectors x and s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!","text":"update_nlp!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, s::Vector{T})\nupdate_nlp!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T})\n\nPerform the partitioned quasi-Newton update given the vectors x and s. When x is omitted, update_PQN! consider that pd_pqn already know the value of x. Moreover, it assumes that the partitioned gradient at x is already computed in pd_pqn.pg.\n\n\n\n\n\n","category":"method"},{"location":"#PartiallySeparableNLPModels.jl","page":"Home","title":"PartiallySeparableNLPModels.jl","text":"","category":"section"},{"location":"tutorial/#PartiallySeparableNLPModels.jl-Tutorial","page":"Tutorial","title":"PartiallySeparableNLPModels.jl Tutorial","text":"","category":"section"}]
}
