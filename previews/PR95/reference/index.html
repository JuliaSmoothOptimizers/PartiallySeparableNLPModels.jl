<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PartiallySeparableNLPModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartiallySeparableNLPModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartiallySeparableNLPModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>​</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><p>​</p><ul><li><a href="#Reference">Reference</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></ul><p>​</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>​</p><ul><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel"><code>PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel"><code>PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel"><code>PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel"><code>PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel"><code>PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel"><code>PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend</code></a></li><li><a href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad</code></a></li><li><a href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad</code></a></li><li><a href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad!</code></a></li><li><a href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad!</code></a></li><li><a href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod</code></a></li><li><a href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod</code></a></li><li><a href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.obj</code></a></li><li><a href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.obj</code></a></li><li><a href="#PartiallySeparableNLPModels.Meta.partitioned_meta-Union{Tuple{T}, Tuple{NLPModels.NLPModelMeta{T, Vector{T}}, PartitionedVectors.PartitionedVector{T}}} where T"><code>PartiallySeparableNLPModels.Meta.partitioned_meta</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function-Tuple{T} where T"><code>PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Utils.distinct_element_expr_tree</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.merge_linear_elements-Tuple{Vector{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}}, Int64}"><code>PartiallySeparableNLPModels.Utils.merge_linear_elements</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.partitioned_structure-Union{Tuple{G}, Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}, G, Int64}} where G"><code>PartiallySeparableNLPModels.Utils.partitioned_structure</code></a></li></ul><p>​</p><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad!(nlp, x, g)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PQNNLPmethods.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad!(nlp, x, g)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PSNLPmethods.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad(nlp, x)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PQNNLPmethods.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad(nlp, x)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PSNLPmethods.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPQNNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PQNNLPmethods.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPartiallySeparableNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PSNLPmethods.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPQNNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PQNNLPmethods.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPartiallySeparableNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PSNLPmethods.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = obj(nlp, x)</code></pre><p>Evaluate <code>f(x)</code>, the objective function of <code>nlp</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PQNNLPmethods.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = obj(nlp, x)</code></pre><p>Evaluate <code>f(x)</code>, the objective function of <code>nlp</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/PSNLPmethods.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Accumulate the supported NLPModels. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/AbstractPNLPModels.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementFunction</code></pre><p>A type that gathers the information indentifying an element function in a <code>PartiallySeparableNLPModel</code>, and its properties. <code>ElementFunction</code> has fields:</p><ul><li><code>i</code>: the index of the element function;</li><li><code>index_element_tree</code>: the index occupied in the element-function vector after the deletion of redundant element functions;</li><li><code>variable_indices</code>: list of elemental variables of <code>ElementFunction</code>;</li><li><code>type</code>: <code>constant</code>, <code>linear</code>, <code>quadratic</code>, <code>cubic</code> or <code>general</code>;</li><li><code>convexity_status</code>: <code>constant</code>, <code>linear</code>, <code>convex</code>, <code>concave</code> or <code>unknown</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/AbstractPNLPModels.jl#L19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T" href="#PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Utils.distinct_element_expr_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(element_expr_trees, indices_element_tree) = distinct_element_expr_tree(vec_element_expr_tree::Vector{T}, vec_element_variables::Vector{Vector{Int}}; N::Int = length(vec_element_expr_tree)) where {T}</code></pre><p>In practice, there may have several element functions having the same expression tree. <code>distinct_element_expr_tree</code> filters the vector <code>vec_element_expr_tree</code> to return <code>element_expr_trees</code> the distincts element functions. <code>length(element_expr_trees) == M &lt; N == length(vec_element_expr_tree)</code>. In addition it returns <code>indices_element_tree</code>, who records the index (1 &lt;= i &lt;= M) related ot the expression tree of each element function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/utils.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.merge_linear_elements-Tuple{Vector{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}}, Int64}" href="#PartiallySeparableNLPModels.Utils.merge_linear_elements-Tuple{Vector{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}}, Int64}"><code>PartiallySeparableNLPModels.Utils.merge_linear_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(vec_element_function, N, linear_vector) = merge_linear_elements(vec_element_function::Vector{ExpressionTreeForge.Type_expr_tree}, N::Int)</code></pre><p>Merge every linear element function from <code>vec_element_function</code> into a single one. Return the new adequate <code>vec_element_function</code>, <code>N</code> and <code>linear_vector::Vector{Bool}</code> of size <code>N</code> indicating with <code>true</code> which element is linear. If the method runs correctly, only <code>linear_vector[N]</code> may be set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/utils.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.partitioned_structure-Union{Tuple{G}, Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}, G, Int64}} where G" href="#PartiallySeparableNLPModels.Utils.partitioned_structure-Union{Tuple{G}, Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}, G, Int64}} where G"><code>PartiallySeparableNLPModels.Utils.partitioned_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitioned_structure = build_PartitionedDataTRPQN(expr_tree, n)</code></pre><p>Return the structure required to run a partitioned quasi-Newton trust-region method.  It finds the partially-separable structure of an expression tree <code>expr_tree</code> representing f(x) = ∑fᵢ(xᵢ). Then it allocates the partitioned structures required. To define properly the sparse matrix of the partitioned matrix we need the size of the problem: <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/utils.jl#L173-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Meta.partitioned_meta-Union{Tuple{T}, Tuple{NLPModels.NLPModelMeta{T, Vector{T}}, PartitionedVectors.PartitionedVector{T}}} where T" href="#PartiallySeparableNLPModels.Meta.partitioned_meta-Union{Tuple{T}, Tuple{NLPModels.NLPModelMeta{T, Vector{T}}, PartitionedVectors.PartitionedVector{T}}} where T"><code>PartiallySeparableNLPModels.Meta.partitioned_meta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meta = partitioned_meta(meta::NLPModels.NLPModelMeta{T, Vector{T}}, x0::PartitionedVector{T})</code></pre><p>Return an <code>NLPModelMeta</code> dedicated to <code>PartitionedVector</code>s, i.e. <code>meta.x0</code> is a <code>PartitionedVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/meta.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel" href="#PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PBFGSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PBFGSNLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PBFGSNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/PBFGSNLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel" href="#PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel"><code>PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PCSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PCS Hessian approximation. <code>PCSNLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PCSNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/PCSNLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel" href="#PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLBFGSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PLBFGS Hessian approximation. <code>PLBFGSNLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PLBFGSNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/PLBFGSNLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel" href="#PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel"><code>PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLSENLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PLSE Hessian approximation. <code>PLSENLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PLSENLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/PLSENLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel" href="#PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel"><code>PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLSR1NLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PLSR1 Hessian approximation. <code>PLSR1NLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PLSR1NLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/PLSR1NLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel" href="#PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel"><code>PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSENLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PSE Hessian approximation. <code>PSENLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PSENLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/PSENLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel" href="#PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel"><code>PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned hessian-vector product. <code>PSNLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PSNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/PSNLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel" href="#PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel"><code>PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSR1NLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned SR1 Hessian approximation. <code>PSR1NLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PSR1NLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/partitionedNLPModels/PSR1NLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient" href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementReverseDiffGradient{T}</code></pre><p>Composed of:</p><ul><li><code>vec_element_gradient_tapes::Vector{ReverseDiff.CompiledTape}</code>, M distinct element function tapes;</li><li><code>index_element_tree::Vector{Int}</code>, from which any of the N element function may associate a gradient tape from <code>vec_element_gradient_tapes</code>.</li></ul><p>Each <code>ReverseDiff.CompiledTape</code> accumlate a element function in a element of a <code>PartitionedVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/backends/GradientBackends/ElementReverseDiffGradient.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod" href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementReverseForwardHprod{T,G}</code></pre><p>Compute the partitioned Hessian-product with <code>partitioned_hessian_prod!</code> by applying successively ReverseDiff and ForwardDiff. It is composed of:</p><ul><li><code>vec_elt_complete_expr_tree::Vector{G}</code>, the expression trees of the distinct element functions (of size M);</li><li><code>index_element_tree::Vector{Int}</code>, reffering to index in <code>vec_elt_complete_expr_tree</code> of any of the N element function;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/backends/HprodBackends/ElementReverseForwardHprod.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend" href="#PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NLPObjectiveBackend{T, Model}</code></pre><p>Composed of <code>nlp::Model</code>, will evaluate the objective function from <code>NLPModels.obj(nlp, x::AbstractVector{T})</code>. The user has to make sure <code>nlp</code> is set to evaluate the desired <code>x::AbstractVector{T}</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/backends/ObjectiveBackends/NLPObjectiveBackend.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function-Tuple{T} where T" href="#PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function-Tuple{T} where T"><code>PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">element_gradient_tape = compiled_grad_element_function(element_function::T; ni::Int = length(ExpressionTreeForge.get_elemental_variables(element_function)), type = Float64) where {T}</code></pre><p>Return the <code>elment_gradient_tape::GradientTape</code> which speed up the gradient computation of <code>element_function</code> with <code>ReverseDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/321f768e9d93c63f99b22fa04bfe5ca7c20a6c69/src/backends/GradientBackends/ElementReverseDiffGradient.jl#L6-L10">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 March 2023 15:08">Thursday 30 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
