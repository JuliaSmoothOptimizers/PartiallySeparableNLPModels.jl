<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PartiallySeparableNLPModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartiallySeparableNLPModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartiallySeparableNLPModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>​</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><p>​</p><ul><li><a href="#Reference">Reference</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></ul><p>​</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>​</p><ul><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel"><code>PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel"><code>PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel"><code>PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel"><code>PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel"><code>PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel"><code>PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend-Tuple{Vector, Vector{Int64}}"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient-Tuple{Vector, Vector{Int64}}"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod-Union{Tuple{G}, Tuple{Vector{G}, Vector{Int64}}} where G"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend-Union{Tuple{G}, Tuple{G, Int64}} where G"><code>PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend-Tuple{Vector}"><code>PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend-Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}}"><code>PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend-Tuple{Vector, Int64}"><code>PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend</code></a></li><li><a href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad</code></a></li><li><a href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad</code></a></li><li><a href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad!</code></a></li><li><a href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad!</code></a></li><li><a href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod</code></a></li><li><a href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod</code></a></li><li><a href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.obj</code></a></li><li><a href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.obj</code></a></li><li><a href="#PartiallySeparableNLPModels.Meta.partitioned_meta-Union{Tuple{T}, Tuple{NLPModels.NLPModelMeta{T, Vector{T}}, PartitionedVectors.PartitionedVector{T}}} where T"><code>PartiallySeparableNLPModels.Meta.partitioned_meta</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function-Tuple{G} where G"><code>PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.objective-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}}} where T"><code>PartiallySeparableNLPModels.PartitionedBackends.objective</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.partitioned_gradient!-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>PartiallySeparableNLPModels.PartitionedBackends.partitioned_gradient!</code></a></li><li><a href="#PartiallySeparableNLPModels.PartitionedBackends.partitioned_hessian_prod!-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>PartiallySeparableNLPModels.PartitionedBackends.partitioned_hessian_prod!</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Utils.distinct_element_expr_tree</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.merge_linear_elements-Tuple{Vector{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}}, Int64}"><code>PartiallySeparableNLPModels.Utils.merge_linear_elements</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.partitioned_structure-Union{Tuple{G}, Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}, G, Int64}} where G"><code>PartiallySeparableNLPModels.Utils.partitioned_structure</code></a></li></ul><p>​</p><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad!(nlp, x, g)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PQNNLPmethods.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad!(nlp, x, g)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PSNLPmethods.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad(nlp, x)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PQNNLPmethods.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.grad-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad(nlp, x)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PSNLPmethods.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPQNNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PQNNLPmethods.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.hprod!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPartiallySeparableNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PSNLPmethods.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPQNNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PQNNLPmethods.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.hprod-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.hprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPartiallySeparableNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PSNLPmethods.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{AbstractPQNNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = obj(nlp, x)</code></pre><p>Evaluate <code>f(x)</code>, the objective function of <code>nlp</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PQNNLPmethods.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}" href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, S}} where {T, S&lt;:AbstractVector{T}}"><code>NLPModels.obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = obj(nlp, x)</code></pre><p>Evaluate <code>f(x)</code>, the objective function of <code>nlp</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/PSNLPmethods.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Accumulate the supported NLPModels. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/AbstractPNLPModels.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementFunction</code></pre><p>A type that gathers the information indentifying an element function in a <code>PartiallySeparableNLPModel</code>, and its properties. <code>ElementFunction</code> has fields:</p><ul><li><code>i</code>: the index of the element function;</li><li><code>index_element_tree</code>: the index occupied in the element-function vector after the deletion of redundant element functions;</li><li><code>variable_indices</code>: list of elemental variables of <code>ElementFunction</code>;</li><li><code>type</code>: <code>constant</code>, <code>linear</code>, <code>quadratic</code>, <code>cubic</code> or <code>general</code>;</li><li><code>convexity_status</code>: <code>constant</code>, <code>linear</code>, <code>convex</code>, <code>concave</code> or <code>unknown</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/AbstractPNLPModels.jl#L19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T" href="#PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Utils.distinct_element_expr_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(element_expr_trees, indices_element_tree) = distinct_element_expr_tree(vec_element_expr_tree::Vector{T}, vec_element_variables::Vector{Vector{Int}}; N::Int = length(vec_element_expr_tree)) where {T}</code></pre><p>In practice, there may have several element functions having the same expression tree. <code>distinct_element_expr_tree</code> filters the vector <code>vec_element_expr_tree</code> to return <code>element_expr_trees</code> the distincts element functions. <code>length(element_expr_trees) == M &lt; N == length(vec_element_expr_tree)</code>. In addition it returns <code>indices_element_tree</code>, who records the index (1 &lt;= i &lt;= M) related ot the expression tree of each element function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/utils.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.merge_linear_elements-Tuple{Vector{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}}, Int64}" href="#PartiallySeparableNLPModels.Utils.merge_linear_elements-Tuple{Vector{ExpressionTreeForge.M_implementation_tree.Type_node{ExpressionTreeForge.M_abstract_expr_node.Abstract_expr_node}}, Int64}"><code>PartiallySeparableNLPModels.Utils.merge_linear_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(vec_element_functions, N, linear_vector) = merge_linear_elements(vec_element_functions::Vector{ExpressionTreeForge.Type_expr_tree}, N::Int)</code></pre><p>Merge every linear element function from <code>vec_element_functions</code> into a single one. Return the new adequate <code>vec_element_functions</code>, <code>N</code> and <code>linear_vector::Vector{Bool}</code> of size <code>N</code> indicating with <code>true</code> which element is linear. If the method runs correctly, only <code>linear_vector[N]</code> may be set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/utils.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.partitioned_structure-Union{Tuple{G}, Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}, G, Int64}} where G" href="#PartiallySeparableNLPModels.Utils.partitioned_structure-Union{Tuple{G}, Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}, G, Int64}} where G"><code>PartiallySeparableNLPModels.Utils.partitioned_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitioned_structure = build_PartitionedDataTRPQN(expr_tree, n)</code></pre><p>Return the structure required to run a partitioned quasi-Newton trust-region method.  It finds the partially-separable structure of an expression tree <code>expr_tree</code> representing f(x) = ∑fᵢ(xᵢ). Then it allocates the partitioned structures required. To define properly the sparse matrix of the partitioned matrix we need the size of the problem: <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/utils.jl#L224-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Meta.partitioned_meta-Union{Tuple{T}, Tuple{NLPModels.NLPModelMeta{T, Vector{T}}, PartitionedVectors.PartitionedVector{T}}} where T" href="#PartiallySeparableNLPModels.Meta.partitioned_meta-Union{Tuple{T}, Tuple{NLPModels.NLPModelMeta{T, Vector{T}}, PartitionedVectors.PartitionedVector{T}}} where T"><code>PartiallySeparableNLPModels.Meta.partitioned_meta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meta = partitioned_meta(meta::NLPModels.NLPModelMeta{T, Vector{T}}, x0::PartitionedVector{T})</code></pre><p>Return an <code>NLPModelMeta</code> dedicated to <code>PartitionedVector</code>s, i.e. <code>meta.x0</code> is a <code>PartitionedVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/meta.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel" href="#PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PBFGSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PBFGSNLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PBFGSNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/PBFGSNLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel" href="#PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel"><code>PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PCSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PCS Hessian approximation. <code>PCSNLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PCSNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/PCSNLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel" href="#PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLBFGSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PLBFGS Hessian approximation. <code>PLBFGSNLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PLBFGSNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/PLBFGSNLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel" href="#PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel"><code>PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLSENLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PLSE Hessian approximation. <code>PLSENLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PLSENLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/PLSENLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel" href="#PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel"><code>PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLSR1NLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PLSR1 Hessian approximation. <code>PLSR1NLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PLSR1NLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/PLSR1NLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel" href="#PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel"><code>PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSENLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using a PSE Hessian approximation. <code>PSENLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PSENLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/PSENLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel" href="#PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel"><code>PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned hessian-vector product. <code>PSNLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PSNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/PSNLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel" href="#PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel"><code>PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSR1NLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned SR1 Hessian approximation. <code>PSR1NLPModel</code> has fields:</p><ul><li><code>model</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PSR1NLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>op</code>: the partitioned matrix (main memory cost);</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/partitionedNLPModels/PSR1NLPModels.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend" href="#PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementMOIModelBackend{T}</code></pre><p>Composed of:</p><ul><li><code>vec_element_evaluators::Vector{MOI.Nonlinear.Evaluator{MOI.Nonlinear.ReverseAD.NLPEvaluator}}</code>, M distinct element function <code>MOI.Nonlinear.Model</code>;</li><li><code>index_element_tree::Vector{Int}</code>, from which any of the N element function may associate a gradient tape from <code>vec_element_gradient_tapes</code>.</li></ul><p>Each <code>MOI.Nonlinear.Evaluator{MOI.Nonlinear.ReverseAD.NLPEvaluator}</code> accumulates the element-function&#39;s contribution in a element-vector of a <code>PartitionedVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GeneralBackends/ElementNonlinearModel.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend-Tuple{Vector, Vector{Int64}}" href="#PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend-Tuple{Vector, Vector{Int64}}"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementMOIModelBackend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">backend = ElementMOIModelBackend(vec_elt_expr_tree::Vector, index_element_tree::Vector{Int}; type=Float64)</code></pre><p>Return an <code>ElementMOIModelBackend</code> from a <code>Vector</code> of expression trees (supported by <a href="https://github.com/JuliaSmoothOptimizers/ExpressionTreeForge.jl">ExpressionTreeForge.jl</a>) of size <code>length(vec_elt_expr_tree)=M</code> and <code>index_element_tree</code> which redirects each element function <code>i</code>  to its corresponding expression tree (1 ≤ <code>index_element_tree[i]</code> ≤ M, 1 ≤ i ≤ N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GeneralBackends/ElementNonlinearModel.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient" href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementReverseDiffGradient{T}</code></pre><p>Composed of:</p><ul><li><code>vec_element_gradient_tapes::Vector{ReverseDiff.CompiledTape}</code>, M distinct element function tapes;</li><li><code>index_element_tree::Vector{Int}</code>, from which any of the N element function may associate a gradient tape from <code>vec_element_gradient_tapes</code>.</li></ul><p>Each <code>ReverseDiff.CompiledTape</code> accumulates the element-function&#39;s contribution in a element-vector of a <code>PartitionedVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GradientBackends/ElementReverseDiffGradient.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient-Tuple{Vector, Vector{Int64}}" href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient-Tuple{Vector, Vector{Int64}}"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseDiffGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradient_brackend = ElementReverseDiffGradient(vec_elt_expr_tree::Vector, index_element_tree::Vector{Int}; type=Float64)</code></pre><p>Return an <code>ElementReverseDiffGradient</code> from a <code>Vector</code> of expression trees (supported by <a href="https://github.com/JuliaSmoothOptimizers/ExpressionTreeForge.jl">ExpressionTreeForge.jl</a>) of size <code>length(vec_elt_expr_tree)=M</code> and <code>index_element_tree</code> which redirects each element function <code>i</code>  to its corresponding expression tree (1 ≤ <code>index_element_tree[i]</code> ≤ M, 1 ≤ i ≤ N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GradientBackends/ElementReverseDiffGradient.jl#L36-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod" href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementReverseForwardHprod{T,G}</code></pre><p>Compute the partitioned Hessian-product with <code>partitioned_hessian_prod!</code> by applying successively ReverseDiff and ForwardDiff. It is composed of:</p><ul><li><code>vec_elt_complete_expr_tree::Vector{G}</code>, the expression trees of the distinct element functions (of size M);</li><li><code>index_element_tree::Vector{Int}</code>, reffering to index in <code>vec_elt_complete_expr_tree</code> of any of the N element function;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/HprodBackends/ElementReverseForwardHprod.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod-Union{Tuple{G}, Tuple{Vector{G}, Vector{Int64}}} where G" href="#PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod-Union{Tuple{G}, Tuple{Vector{G}, Vector{Int64}}} where G"><code>PartiallySeparableNLPModels.PartitionedBackends.ElementReverseForwardHprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod_backend = ElementReverseForwardHprod(complete_trees::Vector, index_element_tree::Vector{Int}; type=Float64)</code></pre><p>Return an <code>ElementReverseForwardHprod</code> from a <code>Vector</code> of expression trees (supported by <a href="https://github.com/JuliaSmoothOptimizers/ExpressionTreeForge.jl">ExpressionTreeForge.jl</a>) <code>vec_elt_expr_tree</code> of size <code>length(vec_elt_expr_tree)=M</code> and <code>index_element_tree</code> which redirects each element function <code>i</code>  to its corresponding expression tree (1 ≤ <code>index_element_tree[i]</code> ≤ M, 1 ≤ i ≤ N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/HprodBackends/ElementReverseForwardHprod.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend" href="#PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MOIObjectiveBackend{T, Model}</code></pre><p>Composed of <code>nlp::Model</code>, it evaluates the objective function from <code>NLPModels.obj(nlp, x::AbstractVector{T})</code>. The user has to make sure <code>nlp</code> is can evaluate <code>x::AbstractVector{T}</code> with a suitable type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/ObjectiveBackends/MOIObjectiveBackend.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend-Union{Tuple{G}, Tuple{G, Int64}} where G" href="#PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend-Union{Tuple{G}, Tuple{G, Int64}} where G"><code>PartiallySeparableNLPModels.PartitionedBackends.MOIObjectiveBackend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MOIObjectiveBackend(nlp::SupportedNLPModel; type=eltype(nlp.meta.x0))</code></pre><p>Create an objective backend from <code>nlp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/ObjectiveBackends/MOIObjectiveBackend.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend" href="#PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModifiedObjectiveMOIModelBackend{T}</code></pre><p>Composed of:</p><ul><li><code>vec_element_evaluators::Vector{MOI.Nonlinear.Evaluator{MOI.Nonlinear.ReverseAD.NLPEvaluator}}</code>, M distinct element function <code>MOI.Nonlinear.Model</code>;</li><li><code>index_element_tree::Vector{Int}</code>, from which any of the N element function may associate a gradient tape from <code>vec_element_gradient_tapes</code>.</li></ul><p>Each <code>MOI.Nonlinear.Evaluator{MOI.Nonlinear.ReverseAD.NLPEvaluator}</code> accumulates the element-function&#39;s contribution in a element-vector of a <code>PartitionedVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GeneralBackends/ModifiedNonlinearBackends.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend-Tuple{Vector}" href="#PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend-Tuple{Vector}"><code>PartiallySeparableNLPModels.PartitionedBackends.ModifiedObjectiveMOIModelBackend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">backend = ModifiedObjectiveMOIModelBackend(vec_elt_expr_tree::Vector, index_element_tree::Vector{Int}; type=Float64)</code></pre><p>Return an <code>ModifiedObjectiveMOIModelBackend</code> from a <code>Vector</code> of expression trees (supported by <a href="https://github.com/JuliaSmoothOptimizers/ExpressionTreeForge.jl">ExpressionTreeForge.jl</a>) of size <code>length(vec_elt_expr_tree)=N</code> and their element variables affiliated. Suppose f(x) = f₁(x) + f₂(x) partially-separable considering the element functions f₁(x) = x₁ * x₂ * x₃² and f₂(x) = x₂ * x₃ * x₄ (N=2), ModifiedObjectiveMOIModelBackend defines a MOI.Nonlinear.Model where F(y) = y₁ * y₂ * y₃² + y₄ * y₅ * y₆ and its evaluator. Each partial derivative of F corresponds to a partial derivative of a single element function fᵢ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GeneralBackends/ModifiedNonlinearBackends.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend" href="#PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NLPObjectiveBackend{T, Model}</code></pre><p>Composed of <code>nlp::Model</code>, it evaluates the objective function from <code>NLPModels.obj(nlp, x::AbstractVector{T})</code>. The user has to make sure <code>nlp</code> is can evaluate <code>x::AbstractVector{T}</code> with a suitable type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/ObjectiveBackends/NLPObjectiveBackend.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend-Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}}" href="#PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend-Tuple{Union{NLPModelsJuMP.MathOptNLPModel, ADNLPModels.ADNLPModel}}"><code>PartiallySeparableNLPModels.PartitionedBackends.NLPObjectiveBackend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NLPObjectiveBackend(nlp::SupportedNLPModel; type=eltype(nlp.meta.x0))</code></pre><p>Create an objective backend from <code>nlp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/ObjectiveBackends/NLPObjectiveBackend.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend" href="#PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend"><code>PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SparseJacobianMoiModelBackend{T}</code></pre><p>Composed of:</p><ul><li><code>evaluator::MOI.Nonlinear.Evaluator{MOI.Nonlinear.ReverseAD.NLPEvaluator}</code>, an evaluator of a <code>MOI.Nonlinear.Model</code> constrained by every element functions;</li><li><code>sparse_jacobian::Vector{T}</code>, mandatory to store in place the sparse Jacobianwith MathOptInterface;</li><li><code>translated_x::PartitionedVector{T}</code>, to handle variables translations, especially when the model doesn&#39;t depend on every variable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GeneralBackends/SparseJacobianBackend.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend-Tuple{Vector, Int64}" href="#PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend-Tuple{Vector, Int64}"><code>PartiallySeparableNLPModels.PartitionedBackends.SparseJacobianMoiModelBackend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">backend = SparseJacobianMoiModelBackend(vec_elt_expr_tree::Vector, n::Int; elemental_variables::Vector{Vector{Int}}), type=Float64)</code></pre><p>Return an <code>SparseJacobianMoiModelBackend</code> from a <code>Vector</code> of expression trees (supported by <a href="https://github.com/JuliaSmoothOptimizers/ExpressionTreeForge.jl">ExpressionTreeForge.jl</a>) of size <code>length(vec_elt_expr_tree)=N</code> and their element variables affiliated. Suppose f(x) = f₁(x) + f₂(x) partially-separable considering the element functions f₁(x) = x₁ * x₂ * x₃² and f₂(x) = x₂ * x₃ * x₄ (N=2), SparseJacobianMoiModelBackend defines a MOI.Nonlinear.Model having f(x) as the objective f₁ and f₂ as two constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GeneralBackends/SparseJacobianBackend.jl#L18-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function-Tuple{G} where G" href="#PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function-Tuple{G} where G"><code>PartiallySeparableNLPModels.PartitionedBackends.compiled_grad_element_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">element_gradient_tape = compiled_grad_element_function(element_function::T; ni::Int = length(ExpressionTreeForge.get_elemental_variables(element_function)), type = Float64) where {T}</code></pre><p>Return the <code>elment_gradient_tape::GradientTape</code> which speed up the gradient computation of <code>element_function</code> with <code>ReverseDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/GradientBackends/ElementReverseDiffGradient.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.objective-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}}} where T" href="#PartiallySeparableNLPModels.PartitionedBackends.objective-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}}} where T"><code>PartiallySeparableNLPModels.PartitionedBackends.objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fx = objective(backend::AbstractObjectiveBackend{T}, x::AbstractVector{T})</code></pre><p>Compute the objective value from <code>backend</code> at the point <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/PartitionedBackends.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.partitioned_gradient!-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}, AbstractVector{T}}} where T" href="#PartiallySeparableNLPModels.PartitionedBackends.partitioned_gradient!-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>PartiallySeparableNLPModels.PartitionedBackends.partitioned_gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitioned_gradient!(backend::AbstractObjectiveBackend{T}, x::AbstractVector{T}, g::AbstractVector{T})</code></pre><p>Compute the partitioned gradient from <code>backend</code> at the point <code>x</code> in place of <code>g</code>. This method is designed for <code>PartitionedVector{T}&lt;:AbstractVector{T}</code> (for now, both <code>x</code> and <code>g</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/PartitionedBackends.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.PartitionedBackends.partitioned_hessian_prod!-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T" href="#PartiallySeparableNLPModels.PartitionedBackends.partitioned_hessian_prod!-Union{Tuple{T}, Tuple{PartiallySeparableNLPModels.PartitionedBackends.PartitionedBackend{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>PartiallySeparableNLPModels.PartitionedBackends.partitioned_hessian_prod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitioned_hessian_prod!(backend::AbstractHprodBackend{T}, x::AbstractVector{T}, v::AbstractVector{T}, Hv::AbstractVector{T})</code></pre><p>Compute the partitioned Hessian-vector product ∇² f(x) v from <code>backend</code> in place of <code>Hv</code>. This method is designed for <code>PartitionedVector{T}&lt;:AbstractVector{T}</code> (<code>x</code>, <code>v</code> and <code>Hv</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/eb14dc048c23cf97b96e7a7002f69d6ccb889a90/src/backends/PartitionedBackends.jl#L35-L40">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 3 April 2023 22:18">Monday 3 April 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
