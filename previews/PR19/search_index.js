var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PartiallySeparableNLPModels, Mod_ab_partitioned_data, Mod_common, Mod_partitionedNLPModel, Mod_PQN]","category":"page"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!-Union{Tuple{Y}, Tuple{Vector{Y}, PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!","text":"evaluate_grad_part_data!(g::Vector{Y}, part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\nevaluate_grad_part_data!(part_data::PartitionedData)\n\nEvaluate in place of g the gradient at the point x after the computation of the element gradients (stored in part_data.pg). When g and x are omitted, it considers that part_data.g and part_data.x are respectively g and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data","text":"gradient = evaluate_grad_part_data(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the gradient vector g at the point x after the computation of the element gradients (stored in part_data.pg).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!-Tuple{PartitionedData}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!","text":"evaluate_obj_part_data!(part_data::PartitionedData)\n\nCompute and store the partially separable objective value stored in part_data, as a sum of element functions, in part_data given part_data.x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data","text":"fx = evaluate_obj_part_data(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the partially separable objective value stored in part_data, computed as a sum of element functions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!","text":"evaluate_y_part_data!(part_data::PartitionedData, x::Vector{Y}, s::Vector{Y}) where {Y <: Number}\nevaluate_y_part_data!(part_data::PartitionedData, s::Vector{Y}) where {Y <: Number}\n\nCompute the element gradients differences such as ∇̂fᵢ(x+s)-∇̂fᵢ(x) for each element functions.  It stores the results in part_data.pv. evaluate_y_part_data!(part_data, s) consider the point part_data.x and the partitioned gradient part_data.pg known.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!-Union{Tuple{Y}, Tuple{Vector{Y}, PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!","text":"product_part_data_x!(res::Vector{Y}, part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\nproduct_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, part_data::PartitionedData, epv::PartitionedStructures.Elemental_pv{Y}) where {Y <: Number}\nproduct_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, pB::T, epv::PartitionedStructures.Elemental_pv{Y}) where {Y <: Number, T <: PartitionedStructures.Part_mat{Y}}\n\nReturn in place of res the product between the partitioned matrix part_data.pB and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x","text":"Bx = product_part_data_x(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the product between the partitioned matrix part_data.pB and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.Element_function","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.Element_function","text":"Element_function\n\nGather the informations indentifying an element function in a PQNNLPModel, and its particular properties. Element_function has fields:\n\ni describing the index of the element function;\nindex_element_tree the index occupied in the element-function vector after the deletion of redundant element functions;\nvariable_indices informing the elemental variable of Element_function\ntype describing Element_function as constant, linear, quadratic, cubic or more non linear;\nconvexity_status describing Element_function as constant, linear, convex, concave or unknown.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function-Tuple{T} where T","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function","text":"element_gradient_tape = compiled_grad_element_function(element_function::T; ni::Int = length(ExpressionTreeForge.get_elemental_variables(element_function)), type = Float64) where {T}\n\nReturn the elment_gradient_tape::GradientTape which speed up the gradient computation of element_function with ReverseDiff.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree","text":"(element_expr_trees, indices_element_tree) = distinct_element_expr_tree(vec_element_expr_tree::Vector{T}, vec_element_variables::Vector{Vector{Int}}; N::Int = length(vec_element_expr_tree)) where {T}\n\nIn practice, there may have several element functions having the same expression tree. distinct_element_expr_tree filters the vector vec_element_expr_tree to return element_expr_trees the distincts element functions. length(element_expr_trees) == M < N == length(vec_element_expr_tree). In addition it returns indices_element_tree, who records the index (1 <= i <= M) related ot the expression tree of each element function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel","text":"Accumulate the supported NLPModels. \n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.PQNNLPModel","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.PQNNLPModel","text":"PQNNLPModel{ T, S, G, M <: AbstractNLPModel{T, S}, Meta <: AbstractNLPModelMeta{T, S}} <: AbstractPQNNLPModel{T, S}\n\nA partitioned quasi-Newton NLPModel. A PQNNLPModel has field:\n\nmeta counting numerous information about the PQNNLPModel;\npart_data allocate the partitioned structures required by a partitioned quasi-Newton trust-region method;\nnlp the original NLPModel.\n\n\n\n\n\n","category":"type"},{"location":"reference/#NLPModels.grad!-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}, AbstractVector{T}}} where {T, S, P<:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPQNNLPModel{T, S}}","page":"Reference","title":"NLPModels.grad!","text":"g = grad!(nlp, x, g)\n\nEvaluate ∇f(x), the gradient of the objective function at x in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NLPModels.obj-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}}} where {T, S, P<:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPQNNLPModel{T, S}}","page":"Reference","title":"NLPModels.obj","text":"f = obj(nlp, x)\n\nEvaluate f(x), the objective function of nlp at x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree-Union{Tuple{NLPModelsJuMP.MathOptNLPModel}, Tuple{T}} where T<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree","text":"expr, n, x0 = get_expr_tree(adnlp::MathOptNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T <: Number}\nexpr, n, x0 = get_expr_tree(adnlp::ADNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T <: Number}\n\nReturn for a MathOptNLPModel or a ADNLPModel: the expression tree of the objective function expr::Expr, the size of the problem n and the initial point x0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.PartitionedData_TR_PQN","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.PartitionedData_TR_PQN","text":"PartitionedData_TR_PQN{G, T <: Number, P <: Part_mat{T}} <: PartitionedData\n\nGather the structures required to run a partitioned quasi-Newton trust-region method. PartitionedData_TR_PQN has fields:\n\nn the size of the problem;\nN the number of element functions;\nvec_elt_fun a Element_function vector, of size N;\nM the number of distinct element-function expression trees;\nvec_elt_complete_expr_tree a Complete_expr_tree vector, of size M;\nelement_expr_tree_table a vector of size M, the i-th element element_expr_tree_table[i]::Vector{Int} informs which element functions have the vec_elt_complete_expr_tree[i] expreesion tree;\nindex_element_tree a vector of size N where each component indicates which Complete_expr_tree from vec_elt_complete_expr_tree use for the corresponding element;\nvec_compiled_element_gradients the vector gathering the compiled tapes for the element gradient evaluations;\nx the current point;\nv a temporary vector;\ns the current step;\npg the partitioned gradient;\npv a temporary partitioned vector;\npy the partitioned gradient difference;\nps the partitioned step;\npB the partitioned matrix (main memory cost);\nfx the current value of the objective function;\nname the name of partitioned quasi-Newton update peformed at each iterate.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.build_PartitionedData_TR_PQN-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T<:Number}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.build_PartitionedData_TR_PQN","text":"partitioneddata_tr_pqn = build_PartitionedData_TR_PQN(expr_tree, n)\n\nReturn the structure required to run a partitioned quasi-Newton trust-region method.  It finds the partially-separable structure of an expression tree expr_tree representing f(x) = ∑fᵢ(xᵢ). Then it allocates the partitioned structures required. Note that to define properly the sparse matrix of the partitioned matrix we need the size of the problem: n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.update_PQN!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.update_PQN!","text":"update_PQN!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, s::Vector{T})\nupdate_PQN!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T})\n\nPerform the partitioned quasi-Newton update given the vectors x and s. When x is omitted, update_PQN! consider that pd_pqn already know the value of x. Moreover, it assumes that the partitioned gradient at x is already computed in pd_pqn.pg.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.update_PQN-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.update_PQN","text":"B = update_PQN(  pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T};\n\nPerform the partitioned quasi-Newton update given the vectors x and s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!","text":"update_nlp!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, s::Vector{T})\nupdate_nlp!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T})\n\nPerform the partitioned quasi-Newton update given the vectors x and s. When x is omitted, update_PQN! consider that pd_pqn already know the value of x. Moreover, it assumes that the partitioned gradient at x is already computed in pd_pqn.pg.\n\n\n\n\n\n","category":"method"},{"location":"#PartiallySeparableNLPModels.jl","page":"Home","title":"PartiallySeparableNLPModels.jl","text":"","category":"section"},{"location":"tutorial/#PartiallySeparableNLPModels.jl-Tutorial","page":"Tutorial","title":"PartiallySeparableNLPModels.jl Tutorial","text":"","category":"section"},{"location":"tutorial/#Motivation","page":"Tutorial","title":"Motivation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The module PartiallySeparableSolvers.jl seeks to minimize the partially separable functions $ f(x) = \\sum{=1}^N \\hat{f}i (Ui x), \\quad f \\in \\R^n \\to \\R, \\quad \\hat fi:\\R^{ni} \\to \\R, \\quad Ui \\in \\R^{ni \\times n}. $ f is a sum of element functions \\hat{f}i and usually n_i ll n. U_i is a linear operator, it selects the variables that parametrizes hatf_i.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PartiallySeparableNLPModels.jl define and manage the structures required by PartiallySeparableSolvers.jl to run a trust-region method that exploits the partially separable structure of f. Mainly, it manages the partitioned derivatives of f, such as the gradient  $ \\nabla f(x) = \\sum{i=1}^N Ui^\\top \\nabla \\hat{f}i (Ui x), $ and the hessian  $ \\nabla^2 f(x) = \\sum{i=1}^N Ui^\\top \\nabla^2 \\hat{fi} (Ui x) Ui, $  where both are the sum of the element derivatives \\nabla \\hat{f}i,  \\nabla^2\\hat{f}i Moreover this structure allows to define a partitioned quasi-Newton approximation of nabla^2 f $ B = \\sum{i=1}^N Ui^\\top \\hat{B}{i} Ui $ where each \\hat{B}i \\approx \\nabla^2 \\hat{f}_i$.","category":"page"},{"location":"tutorial/#Reference","page":"Tutorial","title":"Reference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A. Griewank and P. Toint, Partitioned variable metric updates for large structured optimization problems, Numerische Mathematik volume, 39, pp. 119–137, 1982.","category":"page"},{"location":"tutorial/#Content","page":"Tutorial","title":"Content","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PartiallySeparableNLPModels.jl use the module ExpressionTreeForge.jl to detect automatically the partially separable structure of f. Once it is done, it defines the partitioned structures of nabla f and B approx nabla^2 f with PartitionedStructures.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Considering the following ADNLPModel","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PartiallySeparableNLPModels, ADNLPModels\n\n  function example(x)\n    n = length(x)\n    n < 2 && @error(\"length of x must be >= 2\")\n  return sum( sum( x[j] for j=1:i)^2 for i=2:n)\nend \nstart_example(n :: Int) = ones(n)\nexample_ADNLPModel(n :: Int=100) = ADNLPModel(example, start_example(n), name=\"Example \"*string(n) * \" variables\")\n\nn = 50 # size of the problem\nnlp_example = example_ADNLPModel(n) # example model of ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can either define the structures required for a trust region method using partitioned quasi-Newton update or define an NLPModel to evaluate f nabla f nabla^2 f by exploiting the partial separabiliy of f","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NLPModels\n\npartially_separable_nlp = PQNNLPModel(nlp_example)\nx = rand(n)\nNLPModels.obj(partially_separable_nlp, x) # compute the obective function\nNLPModels.grad(partially_separable_nlp, x) # compute the gradient","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To define the structure for a trust region method, you have to extract ex the Expr from nlp_example and n. You can use","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(ex, n, x0) = get_expr_tree(nlp_example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"after that you can call PartitionedData_TR_PQN","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"part_data_pqn = build_PartitionedData_TR_PQN(ex, n; name=:pbfgs, x0=x0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The sole purpose of this module is to simplify how the module PartiallySeparableSolvers.jl handle the partial separability.","category":"page"}]
}
