var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PartiallySeparableNLPModels, Mod_ab_partitioned_data, Mod_common, Mod_partitionedNLPModel, Mod_PQN]","category":"page"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!-Union{Tuple{Y}, Tuple{Vector{Y}, PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!","text":"evaluate_grad_part_data!(g::Vector{Y}, part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\nevaluate_grad_part_data!(part_data::PartitionedData)\n\nEvaluate in place of g the gradient at the point x after the computation of the element gradients (stored in part_data.pg). When g and x are omitted, it considers that part_data.g and part_data.x are respectively g and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data","text":"gradient = evaluate_grad_part_data(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the gradient vector g at the point x after the computation of the element gradients (stored in part_data.pg).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!-Tuple{PartitionedData}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!","text":"evaluate_obj_part_data!(part_data::PartitionedData)\n\nCompute and store the partially separable objective value stored in part_data, as a sum of element functions, in part_data given part_data.x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data","text":"fx = evaluate_obj_part_data(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the partially separable objective value stored in part_data, computed as a sum of element functions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!","text":"evaluate_y_part_data!(part_data::PartitionedData, x::Vector{Y}, s::Vector{Y}) where {Y <: Number}\nevaluate_y_part_data!(part_data::PartitionedData, s::Vector{Y}) where {Y <: Number}\n\nCompute the element gradients differences such as ∇̂fᵢ(x+s)-∇̂fᵢ(x) for each element functions.  It stores the results in part_data.pv. evaluate_y_part_data!(part_data, s) consider the point part_data.x and the partitioned gradient part_data.pg known.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!-Union{Tuple{Y}, Tuple{Vector{Y}, PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!","text":"product_part_data_x!(res::Vector{Y}, part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\nproduct_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, part_data::PartitionedData, epv::PartitionedStructures.Elemental_pv{Y}) where {Y <: Number}\nproduct_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, pB::T, epv::PartitionedStructures.Elemental_pv{Y}) where {Y <: Number, T <: PartitionedStructures.Part_mat{Y}}\n\nReturn in place of res the product between the partitioned matrix part_data.pB and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{PartitionedData, Vector{Y}}} where Y<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x","text":"Bx = product_part_data_x(part_data::PartitionedData, x::Vector{Y}) where {Y <: Number}\n\nReturn the product between the partitioned matrix part_data.pB and x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.Element_function","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.Element_function","text":"Element_function\n\nGather the informations indentifying an element function in a PQNNLPModel, and its particular properties. Element_function has fields:\n\ni describing the index of the element function;\nindex_element_tree the index occupied in the element-function vector after the deletion of redundant element functions;\nvariable_indices informing the elemental variable of Element_function\ntype describing Element_function as constant, linear, quadratic, cubic or more non linear;\nconvexity_status describing Element_function as constant, linear, convex, concave or unknown.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function-Tuple{T} where T","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function","text":"element_gradient_tape = compiled_grad_element_function(element_function::T; ni::Int = length(ExpressionTreeForge.get_elemental_variables(element_function)), type = Float64) where {T}\n\nReturn the elment_gradient_tape::GradientTape which speed up the gradient computation of element_function with ReverseDiff.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T","page":"Reference","title":"PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree","text":"(element_expr_trees, indices_element_tree) = distinct_element_expr_tree(vec_element_expr_tree::Vector{T}, vec_element_variables::Vector{Vector{Int}}; N::Int = length(vec_element_expr_tree)) where {T}\n\nIn practice, there may have several element functions having the same expression tree. distinct_element_expr_tree filters the vector vec_element_expr_tree to return element_expr_trees the distincts element functions. length(element_expr_trees) == M < N == length(vec_element_expr_tree). In addition it returns indices_element_tree, who records the index (1 <= i <= M) related ot the expression tree of each element function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel","text":"Accumulate the supported NLPModels. \n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.PQNNLPModel","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.PQNNLPModel","text":"PQNNLPModel{ T, S, G, M <: AbstractNLPModel{T, S}, Meta <: AbstractNLPModelMeta{T, S}} <: AbstractPQNNLPModel{T, S}\n\nA partitioned quasi-Newton NLPModel. A PQNNLPModel has field:\n\nmeta counting numerous information about the PQNNLPModel;\npart_data allocate the partitioned structures required by a partitioned quasi-Newton trust-region method;\nnlp the original NLPModel;\ncounters counting the how many standards methods are called.\n\n\n\n\n\n","category":"type"},{"location":"reference/#NLPModels.grad!-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}, AbstractVector{T}}} where {T, S, P<:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPQNNLPModel{T, S}}","page":"Reference","title":"NLPModels.grad!","text":"g = grad!(nlp, x, g)\n\nEvaluate ∇f(x), the gradient of the objective function at x in place.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NLPModels.obj-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}}} where {T, S, P<:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPQNNLPModel{T, S}}","page":"Reference","title":"NLPModels.obj","text":"f = obj(nlp, x)\n\nEvaluate f(x), the objective function of nlp at x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree-Union{Tuple{NLPModelsJuMP.MathOptNLPModel}, Tuple{T}} where T<:Number","page":"Reference","title":"PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree","text":"expr, n, x0 = get_expr_tree(adnlp::MathOptNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T <: Number}\nexpr, n, x0 = get_expr_tree(adnlp::ADNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T <: Number}\n\nReturn for a MathOptNLPModel or a ADNLPModel: the expression tree of the objective function expr::Expr, the size of the problem n and the initial point x0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.PartitionedData_TR_PQN","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.PartitionedData_TR_PQN","text":"PartitionedData_TR_PQN{G, T <: Number, P <: Part_mat{T}} <: PartitionedData\n\nGather the structures required to run a partitioned quasi-Newton trust-region method. PartitionedData_TR_PQN has fields:\n\nn the size of the problem;\nN the number of element functions;\nvec_elt_fun a Element_function vector, of size N;\nM the number of distinct element-function expression trees;\nvec_elt_complete_expr_tree a Complete_expr_tree vector, of size M;\nelement_expr_tree_table a vector of size M, the i-th element element_expr_tree_table[i]::Vector{Int} informs which element functions have the vec_elt_complete_expr_tree[i] expreesion tree;\nindex_element_tree a vector of size N where each component indicates which Complete_expr_tree from vec_elt_complete_expr_tree use for the corresponding element;\nvec_compiled_element_gradients the vector gathering the compiled tapes for the element gradient evaluations;\nx the current point;\nv a temporary vector;\ns the current step;\npg the partitioned gradient;\npv a temporary partitioned vector;\npy the partitioned gradient difference;\nps the partitioned step;\npB the partitioned matrix (main memory cost);\nfx the current value of the objective function;\nname the name of partitioned quasi-Newton update peformed at each iterate.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.build_PartitionedData_TR_PQN-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T<:Number}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.build_PartitionedData_TR_PQN","text":"partitioneddata_tr_pqn = build_PartitionedData_TR_PQN(expr_tree, n)\n\nReturn the structure required to run a partitioned quasi-Newton trust-region method.  It finds the partially-separable structure of an expression tree expr_tree representing f(x) = ∑fᵢ(xᵢ). Then it allocates the partitioned structures required. Note that to define properly the sparse matrix of the partitioned matrix we need the size of the problem: n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.update_PQN!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.update_PQN!","text":"update_PQN!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, s::Vector{T})\nupdate_PQN!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T})\n\nPerform the partitioned quasi-Newton update given the vectors x and s. When x is omitted, update_PQN! consider that pd_pqn already know the value of x. Moreover, it assumes that the partitioned gradient at x is already computed in pd_pqn.pg.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_PQN.update_PQN-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_PQN.update_PQN","text":"B = update_PQN(  pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T};\n\nPerform the partitioned quasi-Newton update given the vectors x and s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedData_TR_PQN{G, T, P}, Vector{T}}} where {G, T<:Number, P<:PartitionedStructures.M_part_mat.Part_mat{T}}","page":"Reference","title":"PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!","text":"update_nlp!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, s::Vector{T})\nupdate_nlp!(pd_pqn::PartitionedData_TR_PQN{G, T, P}, x::Vector{T}, s::Vector{T})\n\nPerform the partitioned quasi-Newton update given the vectors x and s. When x is omitted, update_PQN! consider that pd_pqn already know the value of x. Moreover, it assumes that the partitioned gradient at x is already computed in pd_pqn.pg.\n\n\n\n\n\n","category":"method"},{"location":"#PartiallySeparableNLPModels.jl","page":"Home","title":"PartiallySeparableNLPModels.jl","text":"","category":"section"},{"location":"tutorial/#PartiallySeparableNLPModels.jl-Tutorial","page":"Tutorial","title":"PartiallySeparableNLPModels.jl Tutorial","text":"","category":"section"},{"location":"tutorial/#A-NLPModel-exploiting-the-partial-separability","page":"Tutorial","title":"A NLPModel exploiting the partial separability","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PartiallySeparableNLPModels.jl define NLPModel to implement partitioned quasi-Newton methods exploiting automatically the partially-separable structure of fR^n to R","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":" f(x) = sum_i=1^N f_i (U_i x)   f_i  R^n_i to R  U_i in R^n_i times n n_i ll n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"as the sum of element function f_i.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PartiallySeparableNLPModels.jl relies on ExpressionTreeForge.jl to detect the partially-separable structure and define the suitable partitioned structures, required by the partitioned derivatives, using PartitionedStructures.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a user, you only need to define your ADNLPModel:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PartiallySeparableNLPModels, ADNLPModels\n\nfunction example(x)\n  n = length(x)\n  n < 2 && @error(\"length of x must be >= 2\")\nreturn sum((x[i]+x[i+1])^2 for i=1:n-1)\nend \nstart_example(n :: Int) = ones(n)\nexample_ADNLPModel(n :: Int) = ADNLPModel(example, start_example(n), name=\"Example \" * string(n) * \" variables\")\n\nn = 4 # size of the problem\nadnlp_example = example_ADNLPModel(n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and call PQNNLPModel to define a partitioned quasi-Newton NLPModel:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pqn_adnlp = PQNNLPModel(adnlp_example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, you can apply the usual methods obj and grad, exploiting the partial separability, from NLPModels.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NLPModels\nx = rand(n)\nfx = NLPModels.obj(pqn_adnlp, x) # compute the obective function\ngx = NLPModels.grad(pqn_adnlp, x) # compute the gradient","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The same procedure can be applied to MathNLPModels:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using JuMP, MathOptInterface, NLPModelsJuMP\n\nfunction jump_example(n::Int)\n  m = Model()\n  @variable(m, x[1:n])\n  @NLobjective(m, Min, sum((x[i]^2 + x[i+1])^2 for i = 1:n-1))\n  evaluator = JuMP.NLPEvaluator(m)\n  MathOptInterface.initialize(evaluator, [:ExprGraph])\n  variables = JuMP.all_variables(m)\n  x0 = ones(n)\n  JuMP.set_start_value.(variables, x0)\n  nlp = MathOptNLPModel(m)\n  return nlp\nend\n\njumpnlp_example = jump_example(n)\npqn_jumpnlp = PQNNLPModel(jumpnlp_example)\n\nfx = NLPModels.obj(pqn_jumpnlp, x) # compute the obective function\ngx = NLPModels.grad(pqn_jumpnlp, x) # compute the gradient","category":"page"},{"location":"tutorial/#A-partitioned-quasi-Newton-NLPModel","page":"Tutorial","title":"A partitioned quasi-Newton NLPModel","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By defining a PQNNLPModel you allocate a partitioned quasi-Newton update, which is implemented in PartitionedStructures.jl. You can visualize the matrix with:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"B = Matrix(get_pB(pqn_jumpnlp))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where each element Hessian approximation is instantiated with an identity matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can specify the partitioned quasi-Newton update with the optional argument name:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PQNNLPModel(jumpnlp_example; name=:plse) # by default","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The possible variants are: :pbfg, :psr1, :pse, :plbfgs, :plsr1 and :plse, see the PartitionedStructures.jl tutorial for more details.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, you can update the partitioned quasi-Newton approximation with the pair x,s:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"s = rand(n)\nupdate_B = update_nlp(pqn_adnlp, x, s)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and you can perform the partitioned matrix-vector product with:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"v = ones(n)\nBv = product_part_data_x(pqn_adnlp, v)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A variant allocating in place the result helps to define a LinearOperator (see LinearOperators) from a PQNNLPModel:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LinearOperators\nT = eltype(x)\nlinear_operator = LinearOperators.LinearOperator(T, n, n, true, true, ((res, v) -> product_part_data_x!(res, pqn_adnlp, v)))\nlinear_operator*v","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which can be used later with iterative methods (see Krylov.jl).","category":"page"}]
}
