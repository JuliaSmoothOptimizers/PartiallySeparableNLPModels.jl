<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PartiallySeparableNLPModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartiallySeparableNLPModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartiallySeparableNLPModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>​</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><p>​</p><ul><li><a href="#Reference">Reference</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></ul><p>​</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>​</p><ul><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel"><code>PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel"><code>PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel"><code>PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel"><code>PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel"><code>PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel"><code>PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel</code></a></li><li><a href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, AbstractVector{T}, AbstractVector{T}}} where {T, S}"><code>NLPModels.grad!</code></a></li><li><a href="#NLPModels.hprod!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.hprod!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, AbstractVector{T}}} where {T, S}"><code>NLPModels.obj</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data!-Union{Tuple{S}, Tuple{Y}, Tuple{AbstractVector{Y}, PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data!</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data!</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_y_part_data!-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_y_part_data!</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.hess_approx-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.hess_approx</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.partitionedMulOp!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel, Any, Any, Any, Any}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.partitionedMulOp!</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x-Union{Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x!-Union{Tuple{S}, Tuple{Y}, Tuple{AbstractVector{Y}, PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x!</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel{T, S}, Vector{T}, Vector{T}}} where {T&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp</code></a></li><li><a href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel{T, S}, Vector{T}, Vector{T}}} where {T&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp!</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.compiled_grad_element_function-Tuple{T} where T"><code>PartiallySeparableNLPModels.Utils.compiled_grad_element_function</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Utils.distinct_element_expr_tree</code></a></li><li><a href="#PartiallySeparableNLPModels.Utils.partially_separable_structure-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Utils.partially_separable_structure</code></a></li></ul><p>​</p><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.SupportedNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Accumulate the supported NLPModels. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.ElementFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementFunction</code></pre><p>A type that gathers the information indentifying an element function in a <code>PartiallySeparableNLPModel</code>, and its properties. <code>ElementFunction</code> has fields:</p><ul><li><code>i</code>: the index of the element function;</li><li><code>index_element_tree</code>: the index occupied in the element-function vector after the deletion of redundant element functions;</li><li><code>variable_indices</code>: list of elemental variables of <code>ElementFunction</code>;</li><li><code>type</code>: <code>constant</code>, <code>linear</code>, <code>quadratic</code>, <code>cubic</code> or <code>general</code>;</li><li><code>convexity_status</code>: <code>constant</code>, <code>linear</code>, <code>convex</code>, <code>concave</code> or <code>unknown</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, AbstractVector{T}, AbstractVector{T}}} where {T, S}" href="#NLPModels.grad!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, AbstractVector{T}, AbstractVector{T}}} where {T, S}"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad!(nlp, x, g)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel, AbstractVector, AbstractVector, AbstractVector}" href="#NLPModels.hprod!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPQNNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel, AbstractVector, AbstractVector, AbstractVector}" href="#NLPModels.hprod!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::AbstractPartiallySeparableNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, AbstractVector{T}}} where {T, S}" href="#NLPModels.obj-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{T, S}, AbstractVector{T}}} where {T, S}"><code>NLPModels.obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = obj(nlp, x)</code></pre><p>Evaluate <code>f(x)</code>, the objective function of <code>nlp</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data!-Union{Tuple{S}, Tuple{Y}, Tuple{AbstractVector{Y}, PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data!-Union{Tuple{S}, Tuple{Y}, Tuple{AbstractVector{Y}, PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_grad_part_data!(g::AbstractVector{Y}, psnlp::AbstractPartiallySeparableNLPModel, x::AbstractVector{Y}) where {Y &lt;: Number}
evaluate_grad_part_data!(psnlp::AbstractPartiallySeparableNLPModel)</code></pre><p>Evaluate the gradient at <code>x</code> in place. It computes and store the element gradients in <code>psnlp.pg</code> and accumulate their contributions in <code>g</code>. When <code>g</code> and <code>x</code> are omitted, consider that <code>psnlp.g</code> and <code>psnlp.x</code> are <code>g</code> and <code>x</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/common_methods.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_grad_part_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradient = evaluate_grad_part_data(psnlp::AbstractPartiallySeparableNLPModel, x::AbstractVector{Y}) where {Y &lt;: Number}</code></pre><p>Return the gradient vector <code>g</code> at <code>x</code>. After the computation of the element gradients (stored in <code>psnlp.pg</code>), <code>g</code> is built by accumulating their contributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/common_methods.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_obj_part_data!(psnlp::AbstractPartiallySeparableNLPModel)</code></pre><p>Compute the partially separable objective function, as a sum of element functions, at <code>psnlp.x</code>. Its objective value is stored in <code>psnlp.fx</code> .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/common_methods.jl#L216-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_obj_part_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fx = evaluate_obj_part_data(psnlp::AbstractPartiallySeparableNLPModel, x::AbstractVector{Y}) where {Y &lt;: Number}</code></pre><p>Return the partially separable objective at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/common_methods.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_y_part_data!-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}, AbstractVector{Y}}} where {Y&lt;:Number, S}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_y_part_data!-Union{Tuple{S}, Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.evaluate_y_part_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_y_part_data!(psnlp::AbstractPartiallySeparableNLPModel, x::AbstractVector{Y}, s::AbstractVector{Y}) where {Y &lt;: Number}
evaluate_y_part_data!(psnlp::AbstractPartiallySeparableNLPModel, s::AbstractVector{Y}) where {Y &lt;: Number}</code></pre><p>Compute element gradients differences ∇̂fᵢ(x+s)-∇̂fᵢ(x) for each element function.  Store the results in <code>psnlp.py</code>. When <code>x</code> is ommited, consider <code>psnlp.x</code> as <code>x</code> and <code>psnlp.pg</code> as the partitioned gradient at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/common_methods.jl#L239-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.hess_approx-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.hess_approx-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.hess_approx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">B = hess_approx(nlp::AbstractPQNNLPModel)</code></pre><p>Return the Hessian approximation of <code>nlp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.partitionedMulOp!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel, Any, Any, Any, Any}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.partitionedMulOp!-Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel, Any, Any, Any, Any}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.partitionedMulOp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitionedMulOp!(pqn_nlp::AbstractPQNNLPModel, res, v, α, β)</code></pre><p>Partitioned 5-arg <code>mul!</code> for <code>pqn_nlp</code> using the partitioned matrix and partitioned vectors to destribute and collect the result of element matrix-vector products.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x!-Union{Tuple{S}, Tuple{Y}, Tuple{AbstractVector{Y}, PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x!-Union{Tuple{S}, Tuple{Y}, Tuple{AbstractVector{Y}, PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel{Y, S}, AbstractVector{Y}}} where {Y&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">product_part_data_x!(res::AbstractVector{Y}, psnlp::AbstractPartiallySeparableNLPModel, v::AbstractVector{Y}) where {Y &lt;: Number}
product_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, psnlp::AbstractPartiallySeparableNLPModel, epv::PartitionedStructures.Elemental_pv{Y}) where {Y &lt;: Number}
product_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, pB::T, epv::PartitionedStructures.Elemental_pv{Y}) where {Y &lt;: Number, T &lt;: PartitionedStructures.Part_mat{Y}}</code></pre><p>Store the product between the partitioned matrix <code>psnlp.pB</code> and the vector <code>v</code> in <code>res</code>. The computation of every element matrix-vector product require two partitioned vectors. The first partitioned vector <code>epv</code> is created from <code>v</code> and the results are stored in the second partitioned vector <code>epv_res</code> which builds the value store by <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/common_methods.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x-Union{Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel, AbstractVector{Y}}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x-Union{Tuple{Y}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPartiallySeparableNLPModel, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.product_part_data_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Bx = product_part_data_x(psnlp::AbstractPartiallySeparableNLPModel, v::AbstractVector{Y}) where {Y &lt;: Number}</code></pre><p>Return the product between the partitioned matrix <code>psnlp.pB</code> and <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/common_methods.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel{T, S}, Vector{T}, Vector{T}}} where {T&lt;:Number, S}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp!-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel{T, S}, Vector{T}, Vector{T}}} where {T&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_nlp!(pqn_nlp::AbstractPQNNLPModel{T,S}, s::Vector{T})
update_nlp!(pqn_nlp::AbstractPQNNLPModel{T,S}, x::Vector{T}, s::Vector{T})</code></pre><p>Perform the partitioned quasi-Newton update given the current point <code>x</code> and the step <code>s</code>. When <code>x</code> is omitted, <code>update_PQN!</code> consider that <code>pqn_nlp</code> has the current point in pqn<em>nlp.x<code>. Moreover, it assumes that the partitioned gradient at</code>x<code>is already computed in</code>pqn</em>nlp.pg<code>. Will be replace by</code>push!<code>when</code>PartitionedVector` are implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L184-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel{T, S}, Vector{T}, Vector{T}}} where {T&lt;:Number, S}" href="#PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp-Union{Tuple{S}, Tuple{T}, Tuple{PartiallySeparableNLPModels.ModAbstractPSNLPModels.AbstractPQNNLPModel{T, S}, Vector{T}, Vector{T}}} where {T&lt;:Number, S}"><code>PartiallySeparableNLPModels.ModAbstractPSNLPModels.update_nlp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_nlp(pqn_nlp::AbstractPQNNLPModel{T,S}, x::Vector{T}, s::Vector{T})</code></pre><p>Perform the partitioned quasi-Newton update given the current point <code>x</code> and the step <code>s</code>. When <code>x</code> is omitted, <code>update_PQN!</code> consider that <code>pqn_nlp</code> has the current point in pqn<em>nlp.x<code>. Moreover, it assumes that the partitioned gradient at</code>x<code>is already computed in</code>pqn</em>nlp.pg<code>. Will be replace by</code>push!<code>when</code>PartitionedVector` are implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/AbstractPNLPModels.jl#L166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.compiled_grad_element_function-Tuple{T} where T" href="#PartiallySeparableNLPModels.Utils.compiled_grad_element_function-Tuple{T} where T"><code>PartiallySeparableNLPModels.Utils.compiled_grad_element_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">element_gradient_tape = compiled_grad_element_function(element_function::T; ni::Int = length(ExpressionTreeForge.get_elemental_variables(element_function)), type = Float64) where {T}</code></pre><p>Return the <code>elment_gradient_tape::GradientTape</code> which speed up the gradient computation of <code>element_function</code> with <code>ReverseDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/utils.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T" href="#PartiallySeparableNLPModels.Utils.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Utils.distinct_element_expr_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(element_expr_trees, indices_element_tree) = distinct_element_expr_tree(vec_element_expr_tree::Vector{T}, vec_element_variables::Vector{Vector{Int}}; N::Int = length(vec_element_expr_tree)) where {T}</code></pre><p>In practice, there may have several element functions having the same expression tree. <code>distinct_element_expr_tree</code> filters the vector <code>vec_element_expr_tree</code> to return <code>element_expr_trees</code> the distincts element functions. <code>length(element_expr_trees) == M &lt; N == length(vec_element_expr_tree)</code>. In addition it returns <code>indices_element_tree</code>, who records the index (1 &lt;= i &lt;= M) related ot the expression tree of each element function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/utils.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Utils.partially_separable_structure-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}" href="#PartiallySeparableNLPModels.Utils.partially_separable_structure-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Utils.partially_separable_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitioneddata_tr_pqn = build_PartitionedDataTRPQN(expr_tree, n)</code></pre><p>Return the structure required to run a partitioned quasi-Newton trust-region method.  It finds the partially-separable structure of an expression tree <code>expr_tree</code> representing f(x) = ∑fᵢ(xᵢ). Then it allocates the partitioned structures required. To define properly the sparse matrix of the partitioned matrix we need the size of the problem: <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/utils.jl#L86-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel" href="#PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPBFGSNLPModels.PBFGSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PBFGSNLPModel{G, P, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PBFGSNLPModel</code> has fields:</p><ul><li><code>nlp</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>x</code>: the current point;</li><li><code>v</code>: a temporary vector;</li><li><code>s</code>: the current step;</li><li><code>pg</code>: the partitioned gradient;</li><li><code>pv</code>: a temporary partitioned vector;</li><li><code>py</code>: the partitioned gradient difference;</li><li><code>ps</code>: the partitioned step;</li><li><code>phv</code>: the partitioned Hessian-vector product;</li><li><code>pB</code>: the partitioned matrix (main memory cost);</li><li><code>fx</code>: the current value of the objective function;</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/PBFGSNLPModels.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel" href="#PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel"><code>PartiallySeparableNLPModels.ModPCSNLPModels.PCSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PCSNLPModel{G, P, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PCSNLPModel</code> has fields:</p><ul><li><code>nlp</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>x</code>: the current point;</li><li><code>v</code>: a temporary vector;</li><li><code>s</code>: the current step;</li><li><code>pg</code>: the partitioned gradient;</li><li><code>pv</code>: a temporary partitioned vector;</li><li><code>py</code>: the partitioned gradient difference;</li><li><code>ps</code>: the partitioned step;</li><li><code>phv</code>: the partitioned Hessian-vector product;</li><li><code>pB</code>: the partitioned matrix (main memory cost);</li><li><code>fx</code>: the current value of the objective function;</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/PCSNLPModels.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel" href="#PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel"><code>PartiallySeparableNLPModels.ModPLBFGSNLPModels.PLBFGSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLBFGSNLPModel{G, P, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PLBFGSNLPModel</code> has fields:</p><ul><li><code>nlp</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>x</code>: the current point;</li><li><code>v</code>: a temporary vector;</li><li><code>s</code>: the current step;</li><li><code>pg</code>: the partitioned gradient;</li><li><code>pv</code>: a temporary partitioned vector;</li><li><code>py</code>: the partitioned gradient difference;</li><li><code>ps</code>: the partitioned step;</li><li><code>phv</code>: the partitioned Hessian-vector product;</li><li><code>pB</code>: the partitioned matrix (main memory cost);</li><li><code>fx</code>: the current value of the objective function;</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/PLBFGSNLPModels.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel" href="#PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel"><code>PartiallySeparableNLPModels.ModPLSENLPModels.PLSENLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLSENLPModel{G, P, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PLSENLPModel</code> has fields:</p><ul><li><code>nlp</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>x</code>: the current point;</li><li><code>v</code>: a temporary vector;</li><li><code>s</code>: the current step;</li><li><code>pg</code>: the partitioned gradient;</li><li><code>pv</code>: a temporary partitioned vector;</li><li><code>py</code>: the partitioned gradient difference;</li><li><code>ps</code>: the partitioned step;</li><li><code>phv</code>: the partitioned Hessian-vector product;</li><li><code>pB</code>: the partitioned matrix (main memory cost);</li><li><code>fx</code>: the current value of the objective function;</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/PLSENLPModels.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel" href="#PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel"><code>PartiallySeparableNLPModels.ModPLSR1NLPModels.PLSR1NLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLSR1NLPModel{G, P, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PLSR1NLPModel</code> has fields:</p><ul><li><code>nlp</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>x</code>: the current point;</li><li><code>v</code>: a temporary vector;</li><li><code>s</code>: the current step;</li><li><code>pg</code>: the partitioned gradient;</li><li><code>pv</code>: a temporary partitioned vector;</li><li><code>py</code>: the partitioned gradient difference;</li><li><code>ps</code>: the partitioned step;</li><li><code>phv</code>: the partitioned Hessian-vector product;</li><li><code>pB</code>: the partitioned matrix (main memory cost);</li><li><code>fx</code>: the current value of the objective function;</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/PLSR1NLPModels.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel" href="#PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel"><code>PartiallySeparableNLPModels.ModPSENLPModels.PSENLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSENLPModel{G, P, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PSENLPModel</code> has fields:</p><ul><li><code>nlp</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>x</code>: the current point;</li><li><code>v</code>: a temporary vector;</li><li><code>s</code>: the current step;</li><li><code>pg</code>: the partitioned gradient;</li><li><code>pv</code>: a temporary partitioned vector;</li><li><code>py</code>: the partitioned gradient difference;</li><li><code>ps</code>: the partitioned step;</li><li><code>phv</code>: the partitioned Hessian-vector product;</li><li><code>pB</code>: the partitioned matrix (main memory cost);</li><li><code>fx</code>: the current value of the objective function;</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/PSENLPModels.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel" href="#PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel"><code>PartiallySeparableNLPModels.ModPSNLPModels.PSNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSNLPModel{G, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PSNLPModel</code> has fields:</p><ul><li><code>nlp</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>x</code>: the current point;</li><li><code>v</code>: a temporary vector;</li><li><code>s</code>: the current step;</li><li><code>pg</code>: the partitioned gradient;</li><li><code>pv</code>: a temporary partitioned vector;</li><li><code>py</code>: the partitioned gradient difference;</li><li><code>ps</code>: the partitioned step;</li><li><code>phv</code>: the partitioned Hessian-vector product;</li><li><code>fx</code>: the current value of the objective function;</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/PSNLPModels.jl#L11-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel" href="#PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel"><code>PartiallySeparableNLPModels.ModPSR1NLPModels.PSR1NLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSR1NLPModel{G, P, T, S, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S},} &lt;: AbstractPQNNLPModel{T,S}</code></pre><p>Deduct and allocate the partitioned structures of a NLPModel using partitioned BFGS Hessian approximation. <code>PSR1NLPModel</code> has fields:</p><ul><li><code>nlp</code>: the original model;</li><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called;</li><li><code>n</code>: the size of the problem;</li><li><code>N</code>: the number of element functions;</li><li><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</li><li><code>M</code>: the number of distinct element-function expression trees;</li><li><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</li><li><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</li><li><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</li><li><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</li><li><code>x</code>: the current point;</li><li><code>v</code>: a temporary vector;</li><li><code>s</code>: the current step;</li><li><code>pg</code>: the partitioned gradient;</li><li><code>pv</code>: a temporary partitioned vector;</li><li><code>py</code>: the partitioned gradient difference;</li><li><code>ps</code>: the partitioned step;</li><li><code>phv</code>: the partitioned Hessian-vector product;</li><li><code>pB</code>: the partitioned matrix (main memory cost);</li><li><code>fx</code>: the current value of the objective function;</li><li><code>name</code>: the name of partitioned quasi-Newton update performed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/f33f18f41206022006760ff84c678549c43952f3/src/partitionedNLPModels/PSR1NLPModels.jl#L11-L39">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 23 September 2022 13:59">Friday 23 September 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
