<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PartiallySeparableNLPModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PartiallySeparableNLPModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PartiallySeparableNLPModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>​</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><p>​</p><ul><li><a href="#Reference">Reference</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></ul><p>​</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>​</p><ul><li><a href="#PartiallySeparableNLPModels.Mod_PQN.PartitionedDataTRPQN"><code>PartiallySeparableNLPModels.Mod_PQN.PartitionedDataTRPQN</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_common.ElementFunction"><code>PartiallySeparableNLPModels.Mod_common.ElementFunction</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_partitionedNLPModel.PartiallySeparableNLPModel"><code>PartiallySeparableNLPModels.Mod_partitionedNLPModel.PartiallySeparableNLPModel</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel"><code>PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel</code></a></li><li><a href="#NLPModels.grad!-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}, AbstractVector{T}}} where {T, S, P&lt;:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPartiallySeparableNLPModel{T, S}}"><code>NLPModels.grad!</code></a></li><li><a href="#NLPModels.hprod-Tuple{PartitionedData, AbstractVector, AbstractVector}"><code>NLPModels.hprod</code></a></li><li><a href="#NLPModels.hprod!-Tuple{PartitionedData, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.hprod!-Tuple{PartiallySeparableNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a></li><li><a href="#NLPModels.obj-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}}} where {T, S, P&lt;:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPartiallySeparableNLPModel{T, S}}"><code>NLPModels.obj</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PQN.build_PartitionedDataTRPQN-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PQN.build_PartitionedDataTRPQN</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PQN.update_PQN-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}"><code>PartiallySeparableNLPModels.Mod_PQN.update_PQN</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_PQN.update_PQN!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}"><code>PartiallySeparableNLPModels.Mod_PQN.update_PQN!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!-Union{Tuple{Y}, Tuple{AbstractVector{Y}, PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!-Tuple{PartitionedData}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!-Union{Tuple{Y}, Tuple{AbstractVector{Y}, PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function-Tuple{T} where T"><code>PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree-Union{Tuple{NLPModelsJuMP.MathOptNLPModel}, Tuple{T}} where T&lt;:Number"><code>PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree</code></a></li><li><a href="#PartiallySeparableNLPModels.Mod_partitionedNLPModel.hess_approx-Tuple{PartiallySeparableNLPModel}"><code>PartiallySeparableNLPModels.Mod_partitionedNLPModel.hess_approx</code></a></li></ul><p>​</p><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod!-Tuple{PartitionedData, AbstractVector, AbstractVector, AbstractVector}" href="#NLPModels.hprod!-Tuple{PartitionedData, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(part_data::PartitionedData, x::AbstractVector, v::AbstractVector, hv::AbstractVector)</code></pre><p>Set <code>hv::Vector</code> to the product between the partitioned hessian ∇²f(<code>x</code>) and the vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L335-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod-Tuple{PartitionedData, AbstractVector, AbstractVector}" href="#NLPModels.hprod-Tuple{PartitionedData, AbstractVector, AbstractVector}"><code>NLPModels.hprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hv = hprod(part_data::PartitionedData, x::AbstractVector, v::AbstractVector)</code></pre><p>Return <code>hv::Vector</code> the product between the partitioned hessian ∇²f(<code>x</code>) and the vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L325-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!-Union{Tuple{Y}, Tuple{AbstractVector{Y}, PartitionedData, AbstractVector{Y}}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!-Union{Tuple{Y}, Tuple{AbstractVector{Y}, PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_grad_part_data!(g::AbstractVector{Y}, part_data::PartitionedData, x::AbstractVector{Y}) where {Y &lt;: Number}
evaluate_grad_part_data!(part_data::PartitionedData)</code></pre><p>Evaluate the gradient at <code>x</code> in place. It computes and store the element gradients in <code>part_data.pg</code> and accumulate their contributions in <code>g</code>. When <code>g</code> and <code>x</code> are omitted, consider that <code>part_data.g</code> and <code>part_data.x</code> are <code>g</code> and <code>x</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L291-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_grad_part_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradient = evaluate_grad_part_data(part_data::PartitionedData, x::AbstractVector{Y}) where {Y &lt;: Number}</code></pre><p>Return the gradient vector <code>g</code> at <code>x</code>. After the computation of the element gradients (stored in <code>part_data.pg</code>), <code>g</code> is built by accumulating their contributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L276-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!-Tuple{PartitionedData}" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!-Tuple{PartitionedData}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_obj_part_data!(part_data::PartitionedData)</code></pre><p>Compute the partially separable objective function, as a sum of element functions, at <code>part_data.x</code>. Its objective value is stored in <code>part_data.fx</code> .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L224-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_obj_part_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fx = evaluate_obj_part_data(part_data::PartitionedData, x::AbstractVector{Y}) where {Y &lt;: Number}</code></pre><p>Return the partially separable objective at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}, AbstractVector{Y}}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.evaluate_y_part_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_y_part_data!(part_data::PartitionedData, x::AbstractVector{Y}, s::AbstractVector{Y}) where {Y &lt;: Number}
evaluate_y_part_data!(part_data::PartitionedData, s::AbstractVector{Y}) where {Y &lt;: Number}</code></pre><p>Compute element gradients differences ∇̂fᵢ(x+s)-∇̂fᵢ(x) for each element function.  Store the results in <code>part_data.py</code>. When <code>x</code> is ommited, consider <code>part_data.x</code> as <code>x</code> and <code>part_data.pg</code> as the partitioned gradient at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L247-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!-Union{Tuple{Y}, Tuple{AbstractVector{Y}, PartitionedData, AbstractVector{Y}}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!-Union{Tuple{Y}, Tuple{AbstractVector{Y}, PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">product_part_data_x!(res::AbstractVector{Y}, part_data::PartitionedData, v::AbstractVector{Y}) where {Y &lt;: Number}
product_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, part_data::PartitionedData, epv::PartitionedStructures.Elemental_pv{Y}) where {Y &lt;: Number}
product_part_data_x!(epv_res::PartitionedStructures.Elemental_pv{Y}, pB::T, epv::PartitionedStructures.Elemental_pv{Y}) where {Y &lt;: Number, T &lt;: PartitionedStructures.Part_mat{Y}}</code></pre><p>Store the product between the partitioned matrix <code>part_data.pB</code> and the vector <code>v</code> in <code>res</code>. The computation of every element matrix-vector product require two partitioned vectors. The first partitioned vector <code>epv</code> is created from <code>v</code> and the results are stored in the second partitioned vector <code>epv_res</code> which builds the value store by <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L173-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x-Union{Tuple{Y}, Tuple{PartitionedData, AbstractVector{Y}}} where Y&lt;:Number"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.product_part_data_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Bx = product_part_data_x(part_data::PartitionedData, v::AbstractVector{Y}) where {Y &lt;: Number}</code></pre><p>Return the product between the partitioned matrix <code>part_data.pB</code> and <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/M_partitioned_data.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_common.ElementFunction" href="#PartiallySeparableNLPModels.Mod_common.ElementFunction"><code>PartiallySeparableNLPModels.Mod_common.ElementFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementFunction</code></pre><p>A type that gathers the information indentifying an element function in a <code>PartiallySeparableNLPModel</code>, and its properties. <code>ElementFunction</code> has fields:</p><ul><li><code>i</code>: the index of the element function;</li><li><code>index_element_tree</code>: the index occupied in the element-function vector after the deletion of redundant element functions;</li><li><code>variable_indices</code>: list of elemental variables of <code>ElementFunction</code>;</li><li><code>type</code>: <code>constant</code>, <code>linear</code>, <code>quadratic</code>, <code>cubic</code> or <code>general</code>;</li><li><code>convexity_status</code>: <code>constant</code>, <code>linear</code>, <code>convex</code>, <code>concave</code> or <code>unknown</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/common.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function-Tuple{T} where T" href="#PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function-Tuple{T} where T"><code>PartiallySeparableNLPModels.Mod_common.compiled_grad_element_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">element_gradient_tape = compiled_grad_element_function(element_function::T; ni::Int = length(ExpressionTreeForge.get_elemental_variables(element_function)), type = Float64) where {T}</code></pre><p>Return the <code>elment_gradient_tape::GradientTape</code> which speed up the gradient computation of <code>element_function</code> with <code>ReverseDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/common.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T" href="#PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree-Union{Tuple{T}, Tuple{Vector{T}, Vector{Vector{Int64}}}} where T"><code>PartiallySeparableNLPModels.Mod_common.distinct_element_expr_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(element_expr_trees, indices_element_tree) = distinct_element_expr_tree(vec_element_expr_tree::Vector{T}, vec_element_variables::Vector{Vector{Int}}; N::Int = length(vec_element_expr_tree)) where {T}</code></pre><p>In practice, there may have several element functions having the same expression tree. <code>distinct_element_expr_tree</code> filters the vector <code>vec_element_expr_tree</code> to return <code>element_expr_trees</code> the distincts element functions. <code>length(element_expr_trees) == M &lt; N == length(vec_element_expr_tree)</code>. In addition it returns <code>indices_element_tree</code>, who records the index (1 &lt;= i &lt;= M) related ot the expression tree of each element function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/common.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel" href="#PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel"><code>PartiallySeparableNLPModels.Mod_partitionedNLPModel.SupportedNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Accumulate the supported NLPModels. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitionedNLPModels/partitionedNLPModel.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_partitionedNLPModel.PartiallySeparableNLPModel" href="#PartiallySeparableNLPModels.Mod_partitionedNLPModel.PartiallySeparableNLPModel"><code>PartiallySeparableNLPModels.Mod_partitionedNLPModel.PartiallySeparableNLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PartiallySeparableNLPModel{ T, S, G, M &lt;: AbstractNLPModel{T, S}, Meta &lt;: AbstractNLPModelMeta{T, S}} &lt;: AbstractPartiallySeparableNLPModel{T, S}</code></pre><p>A partitioned quasi-Newton <code>NLPModel</code>. A <code>PartiallySeparableNLPModel</code> has field:</p><ul><li><code>meta</code>: gather information about the <code>PartiallySeparableNLPModel</code>;</li><li><code>part_data</code>: allocate the partitioned structures required by a partitioned quasi-Newton trust-region method;</li><li><code>nlp</code>: the original <code>NLPModel</code>;</li><li><code>counters</code>: count how many standards methods of <code>NLPModels</code> are called.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitionedNLPModels/PartiallySeparableNLPModel.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.grad!-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}, AbstractVector{T}}} where {T, S, P&lt;:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPartiallySeparableNLPModel{T, S}}" href="#NLPModels.grad!-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}, AbstractVector{T}}} where {T, S, P&lt;:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPartiallySeparableNLPModel{T, S}}"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = grad!(nlp, x, g)</code></pre><p>Evaluate <code>∇f(x)</code>, the gradient of the objective function at <code>x</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitionedNLPModels/partitionedNLPModel.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.hprod!-Tuple{PartiallySeparableNLPModel, AbstractVector, AbstractVector, AbstractVector}" href="#NLPModels.hprod!-Tuple{PartiallySeparableNLPModel, AbstractVector, AbstractVector, AbstractVector}"><code>NLPModels.hprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hprod!(nlp::PartiallySeparableNLPModel, x::AbstractVector, v::AbstractVector, Hv::AbstractVector; obj_weight=1.)</code></pre><p>Evaluate the product of the objective Hessian at <code>x</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitionedNLPModels/partitionedNLPModel.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.obj-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}}} where {T, S, P&lt;:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPartiallySeparableNLPModel{T, S}}" href="#NLPModels.obj-Union{Tuple{P}, Tuple{S}, Tuple{T}, Tuple{P, AbstractVector{T}}} where {T, S, P&lt;:PartiallySeparableNLPModels.Mod_partitionedNLPModel.AbstractPartiallySeparableNLPModel{T, S}}"><code>NLPModels.obj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = obj(nlp, x)</code></pre><p>Evaluate <code>f(x)</code>, the objective function of <code>nlp</code> at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitionedNLPModels/partitionedNLPModel.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree-Union{Tuple{NLPModelsJuMP.MathOptNLPModel}, Tuple{T}} where T&lt;:Number" href="#PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree-Union{Tuple{NLPModelsJuMP.MathOptNLPModel}, Tuple{T}} where T&lt;:Number"><code>PartiallySeparableNLPModels.Mod_partitionedNLPModel.get_expr_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expr, n, x0 = get_expr_tree(adnlp::MathOptNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T &lt;: Number}
expr, n, x0 = get_expr_tree(adnlp::ADNLPModel; x0::Vector{T} = copy(adnlp.meta.x0), kwargs...) where {T &lt;: Number}</code></pre><p>Return for a <code>MathOptNLPModel</code> or a <code>ADNLPModel</code>: the expression tree <code>expr::Expr</code> of the objective function, the size of the problem <code>n</code> and the initial point <code>x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitionedNLPModels/partitionedNLPModel.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_partitionedNLPModel.hess_approx-Tuple{PartiallySeparableNLPModel}" href="#PartiallySeparableNLPModels.Mod_partitionedNLPModel.hess_approx-Tuple{PartiallySeparableNLPModel}"><code>PartiallySeparableNLPModels.Mod_partitionedNLPModel.hess_approx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">B = hess_approx(nlp::PartiallySeparableNLPModel)</code></pre><p>Return the Hessian approximation of <code>nlp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitionedNLPModels/partitionedNLPModel.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PQN.PartitionedDataTRPQN" href="#PartiallySeparableNLPModels.Mod_PQN.PartitionedDataTRPQN"><code>PartiallySeparableNLPModels.Mod_PQN.PartitionedDataTRPQN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PartitionedDataTRPQN{G, T &lt;: Number, P &lt;: Part_mat{T}} &lt;: PartitionedData</code></pre><p>Gather the structures required to run a partitioned quasi-Newton trust-region method. <code>PartitionedDataTRPQN</code> has fields:</p><ul><li><p><code>n</code>: the size of the problem;</p></li><li><p><code>N</code>: the number of element functions;</p></li><li><p><code>vec_elt_fun</code>: a <code>ElementFunction</code> vector, of size <code>N</code>;</p></li><li><p><code>M</code>: the number of distinct element-function expression trees;</p></li><li><p><code>vec_elt_complete_expr_tree</code>: a <code>Complete_expr_tree</code> vector, of size <code>M</code>;</p></li><li><p><code>element_expr_tree_table</code>: a vector of size <code>M</code>, the i-th element <code>element_expr_tree_table[i]::Vector{Int}</code> informs which element functions use the <code>vec_elt_complete_expr_tree[i]</code> expression tree;</p></li><li><p><code>index_element_tree</code>: a vector of size <code>N</code> where each component indicates which <code>Complete_expr_tree</code> from <code>vec_elt_complete_expr_tree</code> is used for the corresponding element;</p></li><li><p><code>vec_compiled_element_gradients</code>: the vector gathering the compiled tapes for every element gradient evaluations;</p></li><li><p><code>x</code>: the current point;</p></li><li><p><code>v</code>: a temporary vector;</p></li><li><p><code>s</code>: the current step;</p></li><li><p><code>pg</code>: the partitioned gradient;</p></li><li><p><code>pv</code>: a temporary partitioned vector;</p></li><li><p><code>py</code>: the partitioned gradient difference;</p></li><li><p><code>ps</code>: the partitioned step;</p></li><li><p><code>phv</code>: the partitioned Hessian-vector product;</p></li><li><p><code>pB</code>: the partitioned matrix (main memory cost);</p></li><li><p><code>fx</code>: the current value of the objective function;</p></li><li><p><code>name</code>: the name of partitioned quasi-Newton update performed at each iteration:</p><ul><li><code>name=:pbfgs</code>: every element-Hessian approximation is updated with BFGS;</li><li><code>name=:psr1</code>: every element-Hessian approximation is updated with SR1;</li><li><code>name=:pse</code>: every element-Hessian approximation is updated with BFGS if the curvature condition holds, or with SR1 otherwise;</li><li><code>name=:pcs</code>: each element-Hessian approximation with BFGS if it is classified as <code>convex</code>, or with SR1 otherwise;</li><li><code>name=:plbfgs</code>: every element-Hessian approximations is a LBFGS operator;</li><li><code>name=:plsr1</code>: every element-Hessian approximations is a LSR1 operator;</li><li><code>name=:plse</code>: by default, every element-Hessian approximations is a LBFGS operator as long as the curvature condition holds, otherwise it becomes a LSR1 operator.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitioned_data_pqn.jl#L16-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PQN.build_PartitionedDataTRPQN-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}" href="#PartiallySeparableNLPModels.Mod_PQN.build_PartitionedDataTRPQN-Union{Tuple{T}, Tuple{G}, Tuple{G, Int64}} where {G, T&lt;:Number}"><code>PartiallySeparableNLPModels.Mod_PQN.build_PartitionedDataTRPQN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partitioneddata_tr_pqn = build_PartitionedDataTRPQN(expr_tree, n)</code></pre><p>Return the structure required to run a partitioned quasi-Newton trust-region method.  It finds the partially-separable structure of an expression tree <code>expr_tree</code> representing f(x) = ∑fᵢ(xᵢ). Then it allocates the partitioned structures required. To define properly the sparse matrix of the partitioned matrix we need the size of the problem: <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitioned_data_pqn.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PQN.update_PQN!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}" href="#PartiallySeparableNLPModels.Mod_PQN.update_PQN!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}"><code>PartiallySeparableNLPModels.Mod_PQN.update_PQN!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_PQN!(pd_pqn::PartitionedDataTRPQN{G, T, P}, s::Vector{T})
update_PQN!(pd_pqn::PartitionedDataTRPQN{G, T, P}, x::Vector{T}, s::Vector{T})</code></pre><p>Perform the partitioned quasi-Newton update given the current point <code>x</code> and the step <code>s</code>. When <code>x</code> is omitted, <code>update_PQN!</code> consider that <code>pd_pqn</code> has the current point in pd<em>pqn.x<code>. Moreover, it assumes that the partitioned gradient at</code>x<code>is already computed in</code>pd</em>pqn.pg`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitioned_data_pqn.jl#L119-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_PQN.update_PQN-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}" href="#PartiallySeparableNLPModels.Mod_PQN.update_PQN-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}"><code>PartiallySeparableNLPModels.Mod_PQN.update_PQN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">B = update_PQN(pd_pqn::PartitionedDataTRPQN{G, T, P}, x::Vector{T}, s::Vector{T};</code></pre><p>Perform the partitioned quasi-Newton update given the current point <code>x</code> and the step <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitioned_data_pqn.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}" href="#PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!-Union{Tuple{P}, Tuple{T}, Tuple{G}, Tuple{PartitionedDataTRPQN{G, T, P}, Vector{T}}} where {G, T&lt;:Number, P&lt;:PartitionedStructures.M_part_mat.Part_mat{T}}"><code>PartiallySeparableNLPModels.Mod_ab_partitioned_data.update_nlp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_nlp!(pd_pqn::PartitionedDataTRPQN{G, T, P}, s::Vector{T})
update_nlp!(pd_pqn::PartitionedDataTRPQN{G, T, P}, x::Vector{T}, s::Vector{T})</code></pre><p>Perform the partitioned quasi-Newton update given the current point <code>x</code> and the step <code>s</code>. When <code>x</code> is omitted, <code>update_PQN!</code> consider that <code>pd_pqn</code> has the current point in pd<em>pqn.x<code>. Moreover, it assumes that the partitioned gradient at</code>x<code>is already computed in</code>pd</em>pqn.pg`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/PartiallySeparableNLPModels.jl/blob/564d81301068c4c7fe247ccbd2fa183e6c486c79/src/partitioned_data/partitioned_data_pqn.jl#L83-L90">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 August 2022 12:02">Tuesday 9 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
